# TCPIPDemo
Notes about TCPIP

趣谈网络协议：https://time.geekbang.org/column/85

7层协议图解：https://www.cnblogs.com/wanghuaijun/p/10092930.html

NS3路由模拟实验：https://blog.csdn.net/qq_39564555/article/details/98471596

## 1. 概述
### 1.1 分层
>网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如TCP/IP，是一组不同层次上的多个协议的组合，TCP/IP协议通常被认为是一个四层协议系统：

![image](https://user-images.githubusercontent.com/34849140/143688228-e51c3229-4be1-48d1-a784-c5119e653217.png)
- **链路层**也称为数据链路层或网络接口层，和系统中的设备驱动程序以及计算机中的网络接口卡一起处理与电缆的物理接口细节。
- **网络层**负责处理分组在网络中的活动，例如分组的选路。它包括IP网际协议、ICMP Internet互联网控制报文协议以及IGMP Internet组管理协议。
- **运输层**为两台主机上的应用程序提供端到端的通信，该协议族中有两个传输协议：**TCP传输控制协议**和**UDP用户数据报协议**，两者都是**以IP作为网络层协议**。
  - **TCP**为两台主机提供可靠请的数据通信，把应用程序交给它的数据分成合适的小块交给下面的网络层。TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。本书的17~22章节会详细讨论TCP的内部如何以不可靠的IP服务来提供一种可靠的运输层服务的细节。
  - **UDP**为应用层提供非常简单的服务，只是把称作数据报的分组从一台主机发送到另一台主机，不保证该数据报能到达另一端，可靠性由应用层来提供。本书的第11章讨论UDP、14章DNS、15章TFTP简单文本传输协议以及16章的BOOTP，介绍使用UDP的应用程序。SNMP也使用了UDP协议，放在了25章。
- **应用层**负责处理特定的应用程序细节，各种不同的TCP/IP协议族实现都会提供Telnet、SNMP等应用协议。
>网络层与运输层之间的区别似乎不是那么明显，为什么要把它们划分成两个不同的层次呢？这就要从**单个网络扩展到一组网络**说起。

![image](https://user-images.githubusercontent.com/34849140/144064189-081368f9-2f44-4a09-8d8a-44d8f87e8d06.png)

80年代，为了连接相同协议族却又孤立的系统组在一起形成互连网络，最简单的办法就是通过**路由器**进行连接，它的好处是为不同类型的物理网络提供连接：以太网、令牌环网以及点对点的链接等等。连接网络的另一个途径是使用网桥。**网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连**。网桥使得多个局域网LAN组合在一起，使其对上层来说就像一个局域网。

![image](https://user-images.githubusercontent.com/34849140/144064522-c0d2401c-ee8b-48dd-82c8-37a99df5d422.png)

>TCP/IP倾向于使用路由器而非网桥来连接网络，本书中着重介绍路由器。

**ICMP**是IP协议的附属协议，IP层用它来与其他主机或路由器交换错误和其他重要信息。它也可以被应用程序访问，7、8章节会介绍两个流行诊断工具Ping和Traceroute。

**IGMP**是Internet组管理协议，它用来把一个UDP数据报多播到多个主机，12章中会描述广播（把UDP数据报发送到某个指定网络上的所有主机）的特性。

**ARP和RARP**地址解析协议、逆地址解析协议是某些**网络接口**使用的特殊协议，用来转换IP层和网络接口层使用的地址，4、5章节会进行分析和介绍。

![image](https://user-images.githubusercontent.com/34849140/144064947-8b7d3ff9-cda5-45b4-ba11-a05cc3b4ec61.png)

### 1.2 互联网的地址
互联网上的每个接口必须有一个唯一的Internet地址，也称为IP地址，长32bit。IP地址具有以下5中结构：

![image](https://user-images.githubusercontent.com/34849140/144065435-1c555b32-388e-4c09-bc0d-3817490ebdfd.png)

负责为接入互联网的网络分配IP地址得管理机构称之为InternetNetworkIC互联网络信息中心，它只负责分配网络号，主机号的分配由系统管理员来负责。

![image](https://user-images.githubusercontent.com/34849140/145699143-521d2fdb-c95f-4459-8cdf-74785822e7f7.png)

### 1.3 封装
当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部
信息）。TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）。IP传给网络接口层的数据单元称作IP数据报(IP datagram)，更准确的说法是分组（package）。**通过以太网传输的比特流称作帧(Frame)**。

![image](https://user-images.githubusercontent.com/34849140/144065814-b5cd2461-3576-4213-b583-f79f950fa648.png)

由于TCP、UDP、ICMP和IGMP都要向IP传送数据，因此IP必须在生成的IP首部中加入某种标识，以表明数据属于哪一层。为此IP在首部中存入一个长度为8 bit的数值，称作协议域。1表示为ICMP协议，2表示为IGMP协议，6表示为TCP协议，17表示为UDP协议。类似地，许多应用程序都可以使用TCP或UDP来传送数据。运输层协议在生成报文首部时要存入一个应用程序的标识符。**TCP和UDP都用一个16 bit的端口号来表示不同的应用程序**。TCP和UDP把源端口号和目的端口号分别存入报文首部中。

### 1.4 分用
>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。

![image](https://user-images.githubusercontent.com/34849140/143732468-bd74b760-b6bb-4d9e-b042-6b404e403486.png)

为协议ICMP和IGMP定位一直是一件很棘手的事情。之前把它们与IP放在同一层上，那是因为事实上它们是I P的附属协议。但是在这里又把它们放在IP层的上面，这是**因为ICMP和IGMP报文都被封装在IP数据报中**。
对于ARP和RARP，我们也遇到类似的难题。在这里把它们放在以太网设备驱动程序的上方，这是因为**它们和IP数据报一样，都有各自的以太网数据帧类型**。但在之前我们又把ARP作为以太网设备驱动程序的一部分，放在IP层的下面，其原因在逻辑上是合理的。

### 1.5 端口号
>大部分网络应用程序在编写时都假设一端是客户、一端是服务器。服务器一般都通过知名端口号来识别，比如对每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23。这些知名端口号由Internet号分配机构来管理。客户端通常对它所使用的端口号不关心，只需要保证该端口号（客户端端口号又称为临时端口号）在本机上是唯一的就可以。

### 1.6 应用编程接口
>使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：Transport Layer Interface）。前者有时称作“Berkeley socket”，表明它是从伯克利版发展
而来的。后者起初是由AT & T开发的。

### 1.7 测试网络
本书中所有例子运行的测试网络：

![image](https://user-images.githubusercontent.com/34849140/144066118-1e4e0bf5-46a9-411f-bec7-4c1776c19929.png)

## 2. 链路层
>本章中将详细讨论以太网链路层协议，两个串行接口链路层协议SLIP和PPP以及大多数实现都包含的环回驱动程序。以太网和SLIP是本书中大多数例子使用的链路层。

### 2.1 以太网链路层协议
>以太网是当今TCP/IP采用的主要局域网技术，它采用一种称作为**CSMA/CD（带冲突检测的载波侦听多路接入方法**的媒体接入方法。
- IEEE 802委员会公布了一个稍有不同的标准集，其中802.3针对整个CSMA/CD网络，802.4针对令牌总线网络，802.5针对令牌环网络。这三者的共同特性由802.2标准来定义，那就是802网络共有的逻辑链路控制LLC。IEEE 802网络的IP数据报封装是在RFC 1042[Postel and Reynolds 1988]中定义的。
- 在TCP/IP世界中，以太网IP数据报的封装是在RFC 894[Hornig 1984]中定义的。
两种帧格式都采用48 bit的目的地址和源地址（802.3允许使用16 bit的地址，但一般是48 bit地址），这就是我们在本书中所称的**硬件地址**。

![image](https://user-images.githubusercontent.com/34849140/144066712-6a77270a-291b-40a0-95af-acecf6b678b6.png)

其中的`CRC字段`用于帧内后续字节差错的循环冗余码检验（检验和）（它也被称为FCS或帧检验序列）。

### 2.2 SLP - 全称为串行线路IP
>它是对串行线路上对IP数据报进行封装的简单形式，适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet。
下面的规则描述了S L I P协议定义的帧格式：
- IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符（如果有线路噪声，那么END字符将结束这份错误的报文。这样当前的报文得以正确地传输，而前一个错误报文交给上层后，会发现其内容毫无意义而被丢弃）。
- 如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同。
- 如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。
下图的例子就是含有一个END字符和一个ESC字符的IP报文。在这个例子中，在串行线路上传输的总字节数是原IP报文长度再加4个字节。

![image](https://user-images.githubusercontent.com/34849140/143899626-b8c66d69-62bf-4628-9e9c-9c74dc6f6e8f.png)

SLIP有一些缺点是：
- 数据帧中没有类型字段，如果一条串行线路用于SLIP那么它不能同时使用其他协议。
- SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SL P传输的报文被线路噪声影响而发生错误，只能通过上层协议来发现（另一种方法是，新型的调制解调器可以检测并纠正错误报文）。这样，上层协议提供某种形式的CRC就显得很重要。在第3章和第17章中，我们将看到IP首部和TCP首部及其数据始终都有检验和。在第11章中，将看到UDP首部及其数据的检验和却是可选的。

### 2.3 PPP - 点对点协议
### 2.4 环回接口
大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。
### 2.5 MTU最大传输单元
以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU，最大传输单元。不同类型的网络大多数都有一个上限。如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。我们将在11.5节讨论`IP分片的过程`。

### 2.6 路径MTU

RFC 1191[Mogul and Deering 1990]描述了**路径MTU的发现机制，即在任何时候确定路径MTU的方法**。我们在介绍了ICMP和IP分片方法以后再来看它是如何操作的。在11.6节中，我们将看到ICMP的不可到达错误就采用这种发现方法。在11.7节中，还会看到，traceroute程序也是用这个方法来确定到达目的节点的路径MTU。在11.8节和24.2节，将介绍当产品支持路径MTU的发现方法时，UDP和TCP是如何进行操作的。

## 3. IP - 网际协议
IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输，IP提供不可靠、无连接的数据报传送服务。
- 不可靠的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好
的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。
- 无连接这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能`选择不同的路线`，因此B可能在A到达之前先到达。
- 
>在本章，我们将简要介绍IP首部中的各个字段，讨论IP路由选择和子网的有关内容。还要介绍两个有用的命令：ifconfig和netstat。

### 3.1 IP首部
![image](https://user-images.githubusercontent.com/34849140/143905383-5d92ec75-3686-42db-8214-69d07e06ae54.png)

4个字节的32 bit值以下面的次序传输：首先是0～7 bit，其次8～15 bit，然后16～23 bit，最后是24~31 bit。这种传输次序称作big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作`网络字节序`。以其他形式存储二进制整数的机器，如little endian格式，则必须在`传输数据之前把首部转换成网络字节序`。

目前的协议版本号是4，因此IP有时也称作IPv4。

- `总长度字段`是指整个I P数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节（超级通道MTU为65535。它的意思其实不是一个真正的MTU—它使用了最长的IP数据报）。当数据报被分片时，该字段的值也随着变化，这一点将在11.5节中进一步描述。总长度字段是IP首部中必要的内容，因为一些数据链路（如以太网）需要填充一些数据以达到最小长度。尽管以太网的最小帧长为46字节，但是IP数据可能会更短。如果没有总长度字段，那么IP层就不知道46字节中有多少是IP数据报的内容。
- `标识字段`唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。在11.5节介绍分片和重组时再详细讨论它。同样，在讨论分片时再来分析`标志字段和片偏移字段`。
- `TTL（Time-to-Live）生存时间字段`设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。
- `首部检验和字段`是根据`IP首部计算的检验和码`。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖`首部和数据检验和码`。为了计算一份数据报的IP检验和，首先把检验和字段置为0。然后，对首部中每个16 bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中。当收到一份IP数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。`如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传`。

>关于二进制反码求和用于校验的例子：https://www.jianshu.com/p/4de628b8c91c

以4bit（计算方便一点，和16bit是一样的）做检验和来验证。
假设原始数据为1100，1010，0000（校验位），那么把他们按照4bit一组进行按位取反相加。1100取反0011，1010取反是0101，校验位的计算就是0011加上0101是1000，填入到校验位上于是发送的数据就是1100，1010，1000收到数据后同样进行按位取反相加。0011+0101+0111 =1111；全为1表示正确 。**等于是自己加上自己的取反， 那么 结果肯定应该是全1 。如果传输正确的话。**

### 3.2 IP网际协议的路由选择
>目的主机与源主机直接相连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。
>IP层既可以配置成路由器的功能，也可以配置成主机的功能。当今的大多数多用户系统，包括几乎所有的Unix系统，都可以配置成一个路由器。

在一般的体制中，I P可以从TCP、UDP、ICMP和IGMP接收数据报（即在本地生成的数据报）并进行发送，或者从一个网络接口接收数据报（待转发的数据报）并进行发送。`IP层在内存中有一个路由表`。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到由`IP首部协议字段所指定的协议模块`进行处理。如果数据报的目的不是这些地址，那么
- 如果IP层被设置为路由器的功能，那么就对数据报进行转发（也就是说，像下面对待发出的数据报一样处理）。
- 否则，数据报被丢弃。

路由表中的每一项都包含下面这些信息：
- `目的IP地址`。它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定（如下所述）。`主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）`。
- `下一站（或下一跳）路由器（next-hop router）的IP地址`，或者有直接连接的网络IP地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。
- `标志`。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口（我们将在9.2节中详细介绍这些标志）。
- 为数据报的传输指定一个网络接口。

`完整主机地址匹配在网络号匹配之前执行。只有当它们都失败后才选择默认路由。默认路由，以及下一站路由器发送的ICMP间接报文（如果我们为数据报选择了错误的默认路由）是IP路由选择机制中功能强大的特性。`将在Chapter 9做详细介绍。

`为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性`。这样做可以极大地缩小路由表的规模，比如Internet上的路由器有只有几千个表目，而不会是超过100万个表目。
>EXAMPLE 1

当IP从某个上层收到这份数据报后，它搜索路由表，发现目的I P地址（140.252.13.33）在一个直接相连的网络上（以太网140.252.13.0）。于是，在表中找到匹配网络地址（在下一节中，我们将看到，由于以太网的子网掩码的存在，实际的网络地址是140.252.13.32，但是这并不影响这里所讨论的路由选择）。数据报被送到以太网驱动程序，然后作为一个以太网数据帧被送到sun主机上（见下图）。**IP数据报中的目的地址是sun的IP地址（140.252.13.33），而在链路层首部中的目的地址是48 bit的sun主机的以太网接口地址。这个48 bit的以太网地址是用ARP协议获得的**，我们将在下一章对此进行描述。

![image](https://user-images.githubusercontent.com/34849140/144076871-713d250b-ddb6-4178-9eb2-2fe62b919b09.png)

>EXAMPLE 2

主机bsdi有一份IP数据报要传到ftp.uu.net主机上，它的IP地址是192.48.96.9。经过的前三个路由器如下图。首先，主机bsdi搜索路由表，但是没有找到与主机地址或网络地址相匹配的表目，因此只能用默认的表目，把数据报传给下一站路由器，即主机sun。当数据报从bsdi被传到sun主机上以后，目的IP地址是最终的信宿机地址（192.48.96.9），但是链路层地址却是sun主机的以太网接口地址。这与上图不同，在那里数据报中的目的IP地址和目的链路层地址都指的是相同的主机（sun）。

当sun收到数据报后，它发现数据报的目的IP地址并不是本机的任一地址，而sun已被设置成具有路由器的功能，因此它把数据报进行转发。经过搜索路由表，选用了默认表目。根据sun的默认表目，它把数据报转发到下一站路由器netb，该路由器的地址是140.252.1.183。数据报是经过点对点SLIP链路被传送的，采用了最小封装格式。这里没有给出像以太网链路层数据帧那样的首部，因为在SLIP链路中没有那样的首部。当netb收到数据报后，它执行与sun主机相同的步骤：数据报的目的地址不是本机地址，而netb也被设置成具有路由器的功能，于是它也对该数据报进行转发。采用的也是默认路由表目，把数据报送到下一站路由器gateway（140.252.1.4）。位于以太网140.252.1上的主机netb用ARP获得对应于140.252.1.4的48 bit以太网地址。这个以太网地址就是链路层数据帧头上的目的地址。路由器gateway也执行与前面两个路由器相同的步骤。

![image](https://user-images.githubusercontent.com/34849140/144079642-339d29a3-5237-444c-828b-f62b6a2c255f.png)

### 3.3 子网寻址
>现在所有的主机都要求支持子网编址。**不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号**。这样做的原因是因为A类和B类地址为主机号分配了太多的空间，事实上，在一个网络中人们并不安排这么多的主机。
>在InterNIC获得某类IP网络号后，就由当地的系统管理员来进行分配，由他（或她）来决定是否建立子网，以及分配多少比特给子网号和主机号。例如，这里有一个B类网络地址（140.252），在剩下的16 bit中，8bit用于子网号，8 bit用于主机号，就允许有254个子网，每个子网可以有254台主机。

![image](https://user-images.githubusercontent.com/34849140/144240395-88db4132-79fb-4fc3-9a98-ad8e2fa3a496.png)

**子网对外部路由器来说隐藏了内部网络组织（一个校园或公司内部）的细节**。在我们的网络例子中，所有的IP地址都有一个B类网络号140.252。但是其中有超过30个子网，多于400台主机分布在这些子网中。由一台路由器提供了Internet的接入，如下图：

![image](https://user-images.githubusercontent.com/34849140/144237762-2b33a4f0-5b36-43e8-8436-28b88f4b0dde.png)

在这个图中，我们把大多数的路由器编号为Rn，n是子网号。我们给出了连接这些子网的路由器，同时还包括了扉页前图中的九个系统。在图中，以太网用粗线表示，点对点链路用虚线表示。我们没有画出不同子网中的所有主机。例如，在子网140.252.3上，就超过50台主机，而在子网140.252.1上则超过100台主机。与30个C类地址相比，用一个包含30个子网的B类地址的好处是，它可以缩小Internet路由表的规模。B类地址140.252被划分为若干子网的事实对于所有子网以外的Internet路由器都是透明的。为了到达IP地址开始部分为140.252的主机，外部路由器只需要知道通往IP地址140.252.104.1的路径。这就是说，对于网络140.252只需一个路由表目，而如果采用30个C类地址，则需要30个路由表目。因此，**子网划分缩减了路由表的规模**。

**10.8动态选路协议-无类型域间选路小节中，会介绍一种新技术，即使用C类地址也可以缩减路由表的规模。**

子网对于子网内部的路由器是不透明的。一份来自Internet的数据报到达gateway，它的目的地址是140.252.57.1。路由器gateway需要知道子网号是57，然后把它送到kpno。同样，kpno必须把数据报送到R55，最后R55把它送到R57。

### 3.4 子网掩码
>任何主机在引导时进行的部分配置是指定主机IP地址。大多数系统把IP地址存在一个磁盘文件里供引导时读用。除了IP地址以外，**主机还需要知道有多少比特用于子网号及多少比特用于主机号。这是在引导过程中通过子网掩码来确定的**。这个掩码是一个32 bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。下图是B类地址的两种不同的子网掩码格式。

![image](https://user-images.githubusercontent.com/34849140/144254216-08bb2b38-162e-4897-9d23-a9c79c10ee97.png)

第一个例子是noao.edu网络即上上图采用的子网划分方法，子网号和主机号都是8 bit宽。
第二个例子是一个B类地址划分成10 bit的子网号和6 bit的主机号。

给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：
(1)本子网上的主机；
(2)本网络中其他子网中的主机；
(3)其他网络上的主机。

如果知道本机的IP地址，那么就知道它是否为A类、B类或C类地址(从IP地址的高位可以得知)，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。

>EXAMPLE
假设我们的主机地址是140.252.1.1（一个B类地址），而子网掩码为255.255.255.0（其中8 bit为子网号，8 bit为主机号）。
- 如果目的IP地址是140.252.4.5，那么我们就知道B类网络号是相同的（140.252），但是子网号是不同的（1和4）。用子网掩码在两个IP地址之间的比较如下图所示。

![3 81](https://user-images.githubusercontent.com/34849140/144263926-bf6283e7-4489-40e2-be72-d32707b3404d.png)

- 如果目的IP地址是140.252.1.22，那么B类网络号还是一样的（140.252），而且子网号也是一样的（1），但是主机号是不同的。
- 如果目的IP地址是192.43.235.6（一个C类地址），那么网络号是不同的，因而进一步的比较就不用再进行了。

**给定两个IP地址和子网掩码后，IP路由选择功能一直进行这样的比较。**

>下面这段摘录自：https://zhuanlan.zhihu.com/p/65226634

当网络号子网号不一致的时候（即上面的场景1），TCP/IP协议也会根据子网掩码判定两个网络中的主机处在不同的网络里。**要实现这两个网络之间的通信，则必须通过网关**。如果网络A中的主机发现数据包的目标主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。**网关的IP地址是具有路由功能的设备的IP地址。**

### 3.5 一个子网的例子
图3-10

![image](https://user-images.githubusercontent.com/34849140/144445349-6c1cce3a-655f-48d0-ad9e-c261f2ac9774.png)

从路由器sun到上面的以太网之间的连接细节，实际上它们之间的连接是拨号SLIP。这个细节不影响本节中讨论的子网划分问题。我们在4.6节讨论**ARP代理**时将再回头讨论这个细节。

问题是我们在子网13中有两个分离的网络：一个以太网和一个点对点链路（硬件连接的SLIP链路）（点对点链接始终会带来问题，因为它一般在两端都需要IP地址）。将来或许会有更多的主机和网络，但是为了不让主机跨越不同的网络就得使用不同的子网号。我们的解决方法是把子网号从8 bit扩充到11 bit，把主机号从8 bit减为5 bit。这就叫作**变长子网**，因为140.252网络中的大多数子网都采用8 bit子网掩码，而我们的子网却采用11 bit的子网掩码。

作者子网中的IP地址结构如上图所示，11位子网号中的前8 bit始终是13。在剩下的3 bit中，我们用二进制001表示以太网（所以图中的子网是140.252.13.32，其中的32就是00100000），010表示点对点SLIP链路（子网是140.252.13.64，其中的32就是01000000）。这个变长子网掩码在140.252网络中不会给其他主机和路由器带来问题—只要目的是子网140.252.13的所有数据报都传给路由器sun（IP地址是140.252.1.29），如图下图所示。如果sun知道子网13中的主机有11 bit子网号，那么一切都好办了。

图3-11

![image](https://user-images.githubusercontent.com/34849140/144447210-407f3588-e128-462b-a4ed-35c432c79f75.png)

140.252.13子网中的所有接口的子网掩码是255.255.255.224，或0xffffffe0。这表明最右边的5 bit留给主机号，左边的27 bit留给网络号和子网号。

图3-12

![image](https://user-images.githubusercontent.com/34849140/144451610-de725386-150f-43cb-a3c1-7ce48ac9d680.png)

第1栏标为是“主机”，但是sun和bsdi也具有路由器的功能，因为它们是多接口的，可以把分组数据从一个接口转发到另一个接口。

>这个表中的最后一行是图3-10中的广播地址140.252.13.63：它是根据以太网子网号（140.252.13.32）和图3-11中的低5位置1（16＋8＋4＋2＋1=31）得来的（**我们在第12章中将看到，这个地址被称作以子网为目的的广播地址（subnet-directed broadcast address）**）。

### 3.6 ifcongfig命令

到目前为止，我们已经讨论了链路层和IP层，现在可以介绍TCP/IP对网络接口进行配置和查询的命令了。ifconfig命令一般在引导时运行，以配置主机上的每个接口。

下面是作者子网接口的有关参数：

![image](https://user-images.githubusercontent.com/34849140/144877403-a835193e-89c1-4a06-98de-108aa4b410c6.png)

环回接口被认为是一个网络接口。它是一个A类地址，没有进行子网划分。需要注意的是以太网没有采用尾部封装（2.3节），而且可以进行广播，而SLIP链路是一个点对点的链接。
SLIP接口的标志LINK0是一个允许压缩slip的数据（CSLIP，参见2.5节）的配置选项。其他的选项有LINK1（如果从另一端收到一份压缩报文，就允许采用CSLIP）和LINK2（所有外出的ICMP报文都被丢弃）。我们在4.6节中将讨论**SLIP链接的目的地址**。

## 4. ARP: 地址解析协议

数据链路如以太网或令牌环网都有自己的寻址机制（常常为48 bit地址），这是使用数据链路的任何网络层都必须遵从的。当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48 bit的以
太网地址来确定目的接口的。设备驱动程序从不检查IP数据报中的目的IP地址。地址解析为这两种不同的地址形式提供映射：32 bit的IP地址和数据链路层使用的任何类型的地址。

![image](https://user-images.githubusercontent.com/34849140/144614367-a454f5d4-1f90-4b87-8cdc-1279057afc55.png)

### 4.1 例子

ARP为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心。**RARP是被那些没有磁盘驱动器的系统使用（一般是无盘工作站或X终端），它需要系统管理员进行手工设置。我们在第5章对它进行讨论。**

>EXAMPLE

任何时候我们敲入下面这个形式的命令：
% ftp bsdi
都会进行以下这些步骤。这些步骤的序号如图4-2所示：
- 1.应用程序FTP客户端调用函数gethostbyname(3)把主机名（bsdi）转换成32 bit的IP地址。这个函数在DNS（域名系统）中称作解析器，我们将在第14章对它进行介绍。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/hosts）。
- 2.FTP客户端请求TCP用得到的IP地址建立连接。
- 3.TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报（在第18章我们将讨论完成这个过程的细节）。
- 4.如果目的主机在本地网络上（如以太网、令牌环网或点对点链接的另一端），那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，那么就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。在这两种情况下，IP数据报都是被送到位于本地网络上的一台主机或路由器。
- 5.假定是一个以太网，那么发送端主机必须把32 bit的IP地址变换成48 bit的以太网地址。**从逻辑Internet地址到对应的物理硬件地址需要进行翻译。这就是ARP的功能。ARP本来是用于广播网络的，有许多主机或路由器连在同一个网络上。**
- 6.ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播，如图4-2中的虚线所示。ARP请求数据帧中包含目的主机的IP地址（主机名为bsdi），其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”
- 7.目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。
- 8.收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。
- 9.发送IP数据报到目的主机。

图4-2：

![image](https://user-images.githubusercontent.com/34849140/144616034-1a370f63-7b65-4774-a18b-ca3e3a15bf92.png)

在ARP背后有一个基本概念，那就是网络接口有一个硬件地址（一个48 bit的值，标识不同的以太网或令牌环网络接口）。`在硬件层次上进行的数据帧交换必须有正确的接口地址`。但是，TCP/IP有自己的地址：32 bit的IP地址。知道主机的IP地址并不能让内核发送一帧数据给主机。`内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据`。ARP的功能是在32 bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。

点对点链路不使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址。像以太网地址这样的硬件地址并不涉及。

### 4.2 ARP高速缓存

ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。
我们可以用arp命令来检查ARP高速缓存。参数-a的意思是显示高速缓存中所有的内容。

```shell
bsdi % arp -a
sun (140.252.13.33) at 8:0:20:3:f6:42
svr4 (140.252.13.34) at 0:0:c0:c2:9b:26
```

### 4.3 ARP的分组格式

在以太网上解析IP地址时，ARP请求和应答分组的格式如图4-3所示（ARP可以用于其他类型的网络，可以解析IP地址以外的地址。紧跟着帧类型字段的前四个字段指定了最后四个字段的类型和长度）。

![image](https://user-images.githubusercontent.com/34849140/144627320-9c8761dc-5d98-404d-ace1-c45a0356e136.png)

- 以太网报头中的前两个字段是以太网的源地址和目的地址。`目的地址为全1的特殊地址是广播地址`。电缆上的所有以太网接口都要接收广播的数据帧。两个字节长的以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。
- 形容词hardware (硬件)和protocol (协议)用来描述ARP分组中的各个字段。例如，一个ARP请求分组询问协议地址（这里是IP地址）对应的硬件地址（这里是以太网地址）。
- 硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。`协议类型字段表示要映射的协议地址类型。它的值为0x0800即表示IP地址`。它的值与包含IP数据报的以太网数据帧中的类型字段的值相同，这是有意设计的。
- 接下来的两个1字节的字段，硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。
- 操作字段指出四种操作类型，它们是ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）（我们在第5章讨论RARP）。这个字段必需的，因为ARP请求和ARP应答的帧类型字段值是相同的。

### 4.4 ARP举例

还是以图4-2中的网络作为对象，用tcpdump命令来看一看运行像Telnet这样的普通TCP工具软件时ARP会做些什么。

#### 4.4.1 一般例子

为了看清楚ARP的运作过程，我们执行telnet命令与无效的服务器连接：

![image](https://user-images.githubusercontent.com/34849140/144635356-94fb4d9e-15da-4998-9032-16782a94675a.png)

当我们在另一个系统（sun）上运行带有-e选项的tcpdump命令时，显示的是硬件地址（在我们的例子中是48 bit的以太网地址）。输出信息如下：

![image](https://user-images.githubusercontent.com/34849140/144635799-71ae3444-73e3-4f0e-8749-c206ff43954b.png)

- 第1行中，源端主机（bsdi）的硬件地址是0:0:c0:6f:2d:40。目的端主机的硬件地址是ff:ff:ff:ff:ff:ff，这是一个以太网广播地址。电缆上的每个以太网接口都要接收这个数据帧并对它进行处理（上面的图所示）。
- 1行中紧接着的一个输出字段是arp，表明帧类型字段的值是0x0806，说明此数据帧是一个ARP请求或回答。在每行中，单词arp或ip后面的值60指的是以太网数据帧的长度。由于ARP请求或回答的数据帧长都是42字节（28字节的ARP数据，14字节的以太网帧头），因此，每一帧都必须加入填充字符以达到以太网的最小长度要求：60字节。
- 1行中的下一个输出字段arp who-has表示作为ARP请求的这个数据帧中，目的IP地址是svr4的地址，发送端的IP地址是bsdi的地址。tcpdump打印出主机名对应的默认IP地址（在4.7节中，我们将用-n选项来查看ARP请求中真正的IP地址。）从第2行中可以看到，尽管ARP请求是广播的，但是ARP应答的目的地址却是bsdi（0:0:c0:6f:2d:40）。ARP应答是直接送到请求端主机的，而是广播的。tcpdump打印出arp reply的字样，同时打印出响应者的主机名和硬件地址。
- 3行是第一个请求建立连接的TCP段。它的目的硬件地址是目的主机(svr4)。我们将在第18章讨论这个段的细节内容。在每一行中，行号后面的数字表示tcpdump收到分组的时间（以秒为单位）。除第1行外，其他每行在括号中还包含了与上一行的时间差异（以秒为单位）。从这个图可以看出，发送ARP请求与收到ARP回答之间的延时是2.2 ms。而在0.7 ms之后发出第一段TCP报文。在本例中，用ARP进行动态地址解析的时间小于3 ms。

使用了Windows和其上面的虚拟机Centos实践如下：

```shell
arp -a
```

![image](https://user-images.githubusercontent.com/34849140/144704018-5a09072c-4064-4b59-8af0-b3455d277372.png)

```shell
C:\Users\zhou>arp -d
C:\Users\zhou>arp -a
接口: 192.168.88.1 --- 0x5
  Internet 地址         物理地址              类型
  224.0.0.22            01-00-5e-00-00-16     静态
  224.0.0.252           01-00-5e-00-00-fc     静态
接口: 192.168.31.122 --- 0xb
  Internet 地址         物理地址              类型
  192.168.31.1          3c-cd-57-59-4f-b2     动态
  224.0.0.2             01-00-5e-00-00-02     静态
  224.0.0.22            01-00-5e-00-00-16     静态
  224.0.0.252           01-00-5e-00-00-fc     静态
接口: 192.168.29.1 --- 0x10
  Internet 地址         物理地址              类型
  224.0.0.22            01-00-5e-00-00-16     静态
  224.0.0.252           01-00-5e-00-00-fc     静态

C:\Users\zhou>telnet 192.168.29.132
```
tcpdump抓包：

![image](https://user-images.githubusercontent.com/34849140/144705820-26ba5156-02ed-4d9a-be3a-ad3fd4136a84.png)

>疑问：
让人困惑的是ARP响应为什么是`192.168.29.2 is at 00:50:56:ee:34:f4`?虚拟机的地址是29.132，后面DNS报文中的29.1是Windows地址，这个疑问暂时格式，可能和DNS相关。

#### 4.4.2 对不存在主机的ARP请求

指定一个并不存在的Internet地址—根据网络号和子网号所对应的网络确实存在，但是并不存在所指定的主机号。主机号从36到62的主机并不存在（主机号为63是广播地址）。这里，我们用主机号36来举例（这次是Telnet的一个地址，而不是主机名）。

![image](https://user-images.githubusercontent.com/34849140/144706401-fc0acdcd-d9b5-4b77-b023-abd3bb712cbe.png)

![image](https://user-images.githubusercontent.com/34849140/144706424-4a27ccf5-262c-4bfd-8cea-7f8027de3f24.png)

ARP请求是在网上广播的。令人感兴趣的是看到多次进行ARP请求：第1次请求发生后5.5秒进行第2次请求，在24秒之后又进行第3次请求（在第21章我们将看到TCP的超时和重发算法的细节）。tcpdump命令输出的超时限制为29.5秒。但是，在telnet命令使用前后分别用date命令检查时间，可以发现Telnet客户端的连接请求似乎在大约75秒后才放弃。

注意，在线路上始终看不到TCP的报文段。我们能看到的是ARP请求。直到ARP回答返回时，TCP报文段才可以被发送，因为硬件地址到这时才可能知道。如果我们用过滤模式运行tcpdump命令，只查看TCP数据，那么将没有任何输出。

### 4.5 ARP代理

如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作`委托ARP或ARP代理(Proxy ARP)`。这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把`分组`从其他主机转发给它。

图3-10所示，**系统sun与两个以太网相连。但是，我们也指出过，事实上并不是这样，在sun和子网140.252.1之间实际存在一个路由器**，就是这个具有ARP代理功能的路由器使得sun就好像在子网140.252.1上一样。

具体安置如下图所示，路由器Telebit NetBlazer，取名为netb，在子网和主机sun之间：

![image](https://user-images.githubusercontent.com/34849140/144709256-bf31dcbc-23b9-47dd-88e8-5a832c61425d.png)

当子网140.252.1（称作gemini）上的其他主机有一份IP数据报要传给地址为140.252.1.29的sun时，gemini比较网络号（140.252）和子网号1，因为它们都是相同的，因而在图上面的以太网中发送IP地址140.252.1.29的ARP请求。路由器netb识别出该IP地址属于它的一个拔号主机，于是把它的以太网接口地址作为硬件地址来回答。主机gemini通过以太网发送IP数据报到netb，netb通过拨号SLIP链路把数据报转发到sun。这个过程对于所有140.252.1子网上的主机来说都是透明的。

如果在主机gemini上执行arp命令，经过与主机sun通信以后，我们发现在同一个子网140.252.1上的netb和sun的IP地址映射的硬件地址是相同的。这通常是使用委托ARP的线索。

![image](https://user-images.githubusercontent.com/34849140/144709290-75a726c0-7e92-4bfa-a120-953fd0c8b705.png)

另一个需要解释的细节是在路由器netb的下方（SLIP链路）显然缺少一个IP地址。为什么在拨号SLIP链路的两端只拥有一个IP地址，而在bsdi和slip之间的两端却分别有一个IP地址？

之前说过，用ifconfig命令可以显示拨号SLIP链路的目的地址，它是140.252.1.183。***NetBlazer不需要知道拨号SLIP链路每一端的IP地址（这样做会用更多的IP地址）。相反，它通过分组到达的串行线路接口来确定发送分组的拨号主机，因此对于连接到路由器的每个拨号主机不需要用唯一的IP地址。所有的拨号主机使用同一个IP地址140.252.1.183作为SLIP链路的目的地址...没看懂。***

ARP代理可以把数据报传送到路由器sun上，但是子网140.252.13上的其他主机是如何处理的呢？选路必须使数据报能到达其他主机。这里需要特殊处理，选路表中的表项必须在网络140.252的某个地方制定，使所有数据报的目的端要么是子网140.252.13，要么是子网上的某个主机，这样都指向路由器netb。而路由器netb知道如何把数据报传到最终的目的端，即通过路由器sun。

## 5. RARP: 逆地址解析协议（略）

## 6. ICMP: Internet控制报文协议

>ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（TCP或UDP）使用。一些ICMP报文把差错报文返回给用户进程。

>本章重点：我们将一般地讨论ICMP报文，并对其中一部分作详细介绍：地址掩码请求和应答、时间戳请求和应答以及不可达端口。我们将详细介绍第7章Ping程序所使用的回应请求和应答报文和第9章处理IP路由的ICMP报文。

**ICMP报文是在IP数据报内部被传输的**，如下图：

![image](https://user-images.githubusercontent.com/34849140/144709700-27a9037d-7a81-4e16-9089-1b253f910e18.png)

ICMP报文的格式如图所示。所有报文的前4个字节都是一样的，但是剩下的其他字节则互不相同。下面我们将逐个介绍各种报文格式。类型字段可以有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代
码字段的值来进一步描述不同的条件。

`检验和字段覆盖整个ICMP报文。使用的算法与我们在3章节介绍的IP首部检验和算法相同。ICMP的检验和是必需的.`

![image](https://user-images.githubusercontent.com/34849140/144731359-b33df168-da93-4e7b-8d7a-bf83f055b992.png)

### 6.1 ICMP报文的类型

>不同类型由报文中的类型字段和代码字段来共同决定。图中的最后两列表明ICMP报文是一份查询报文还是一份差错报文。因为对ICMP差错报文有时需要作特殊处理，因此我们需要对它们进行区分。例如，在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文。

![image](https://user-images.githubusercontent.com/34849140/144714320-c11f707d-4174-43de-bbf3-01444ab4595b.png)

当发送一份ICMP差错报文时，报文始终包含IP的首部和产生ICMP差错报文的IP数据报的前8个字节。这样，接收ICMP差错报文的模块就会把它与某个特定的协议（根据IP数据报首部中的协议字段来判断）和用户进程（根据包含在IP数据报前8个字节中的TCP或UDP报文首部中的TCP或UDP端口号来判断）联系起来。6.5节将举例来说明一点。

### 6.2 ICMP查询报文 - ICMP地址掩码请求与应答(内核中处理-略)

ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码（3.5节）。系统广播它的ICMP请求报文（这一过程与无盘系统在引导过程中用RARP获取IP地址是类似的）。无盘系统获取子网掩码的另一个方法是BOOTP协议，我们将在第16章中介绍。

![image](https://user-images.githubusercontent.com/34849140/144731410-f19fd2d5-48ce-419e-9138-2440aef19989.png)

### 6.3 ICMP查询报文 - ICMP时间戳请求与应答（内核中处理）

>ICMP时间戳请求允许系统向另一个系统查询当前的时间。返回的建议值是自午夜开始计算的毫秒数，协调的统一时间（Coordinated Universal Time, UTC）。这种ICMP报文的好处是它提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间（如某些Unix系统提供的rdate命令）只能提供秒级的分辨率。由于返回的时间是从午夜开始计算的，因此调用者必须通过其他方法获知当时的日期，这是它的一个缺陷。

![image](https://user-images.githubusercontent.com/34849140/144731439-f7955e3d-0a32-4475-b456-94017f372a72.png)

#### 6.3.1 ICMP时间戳请求

我们还能计算出往返时间（rtt），它的值是收到应答时的时间值减去发送请求时的时间值。difference的值是接收时间戳值减去发起时间戳值。如果我们相信RTT的值，并且相信RTT的一半用于请求报文的传输，另一半用于应答报文的传输，那么为了使本机时钟与查询主机的时钟一致，本机时钟需要进行调整。

#### 6.3.2  获取时间和日期的其他方法

- 严格的计时器使用网络时间协议（NTP），该协议在RFC 1305中给出了描述。这个协议采用先进的技术来保证LAN或WAN上的一组系统的时钟误差在毫秒级以内。
- 放软件基金会（OSF）的`分布式计算环境`（DCE）定义了`分布式时间服务（DTS）`，它也提供计算机之间的时钟同步。文献[Rosen berg, Kenney and Fisher 1992]提供了该服务的其他细节描述。 
- 伯克利大学的Unix系统提供守护程序timed，来同步局域网上的系统时钟。不像NTP和DTS，timed不在广域网范围内工作。

### 6.4 ICMP差错报文 - ICMP端口不可达
>UDP（11章描述）的规则之一是，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。可以用TFTP来强制生成一个端口不可达报文（TFTP将在第15章描述）。

对于TFTP服务器来说，UDP的公共端口号是69。但是大多数的TFTP客户程序允许用connect命令来指定一个不同的端口号。这里，我们就用它来指定8888端口：

![image](https://user-images.githubusercontent.com/34849140/144715239-942edcbd-2f19-4ef1-bd74-91c87ac1f52d.png)

connect命令首先指定要连接的主机名及其端口号，接着用get命令来取文件。敲入get命令后，一份UDP数据报就发送到主机svr4上的8888端口。tcpdump命令引起的报文交换结果如图所示：

![image](https://user-images.githubusercontent.com/34849140/144715225-a4811244-860b-45cb-8d6c-e7561f805a84.png)

注意，ICMP报文是在主机之间交换的，而不用目的端口号，而每个20字节的UDP数据报则是从一个特定端口（2924）发送到另一个特定端口（8888）。跟在每个UDP后面的数字20指的是UDP数据报中的数据长度。在这个例子中，20字节包括TFTP的2个字节的操作代码，9个字节以空字符结束的文件名temp.foo，以及9个字节以空字符结束的字符串netascii（TFTP报文的详细格式参见图15-1）。

如果用- e选项运行同样的例子，我们可以看到每个返回的ICMP端口不可达报文的完整长度。这里的长度为70字节，各字段分配如图所示：

![image](https://user-images.githubusercontent.com/34849140/144715423-77c71e1f-b79f-4b62-a138-5edb7ff668e7.png)

![image](https://user-images.githubusercontent.com/34849140/144731477-7409fae9-fe8d-416e-a510-a856328ba03f.png)

ICMP的一个规则是，ICMP差错报文必须包括生成该差错报文的数据报IP首部（包含任何选项），还必须至少包括跟在该IP首部后面的前8个字节。在我们的例子中，跟在IP首部后面的前8个字节包含UDP的首部。

![image](https://user-images.githubusercontent.com/34849140/144716047-054ebec1-ad3b-4266-adf4-ad95536c0c97.png)

一个重要的事实是包含在UDP首部中的内容是源端口号和目的端口号。就是由于目的端口号（8888）才导致产生了ICMP端口不可达的差错报文。接收ICMP的系统可以根据源端口号（2924）来把差错报文与某个特定的用户进程相关联（在本例中是TFTP客户程序）。

导致差错的数据报中的IP首部要被送回的原因是因为IP首部中包含了协议字段，使得ICMP可以知道如何解释后面的8个字节（在本例中是UDP首部）。

在本书的后面章节中，我们还要以时间系列的格式给出tcpdump命令的输出，如下图所示：

![image](https://user-images.githubusercontent.com/34849140/144717364-c54d99fb-9c6e-4605-b55f-3947f67bcb9f.png)

当ICMP报文返回时，为什么TFTP客户程序还要继续重发请求呢？这是由于网络编程中的一个因素，即**BSD系统不把从插口(socket)接收到的ICMP报文中的UDP数据通知用户进程，除非该进程已经发送了一个connect命令给该插口**。标准的BSD TFTP客户程序并不发送connect命令，因此它永远也不会收到ICMP差错报文的通知。

## 7. Ping程序

>ICMP的一个重要应用就是分组网间探测 PING（Packet InterNet Groper），用来测试两台主机之间的连通性。**Ping程序由Mike Muuss编写**，使用了ICMP回送请求与回送回答报文（ICMP查询报文的一种，见6.1中的图）。PING是应用层直接使用网络层ICMP的一个例子。他没有通过传输层的TCP或UDP。

>在本章中，我们将使用Ping程序作为诊断工具来深入剖析ICMP。Ping还给我们提供了检测IP记录路由和时间戳选项的机会。文献[Stevens 1990]的第11章提供了Ping程序的源代码。

>几年前我们还可以作出这样没有限定的断言，如果不能Ping到某台主机，那么就不能Telnet或FTP到那台主机。随着Internet安全意识的增强，出现了提供访问控制清单的路由器和防火墙，那么像这样没有限定的断言就不再成立了。一台主机的可达性可能不只取决于IP层是否可达，还取决于使用何种协议以及端口号。**Ping程序的运行结果可能显示某台主机不可达，但我们可以用Telnet远程登录到该台主机的25号端口（邮件服务器）。**

### 7.1 Ping程序

发送回显请求的ping程序为客户，而称被ping的主机为服务器。**大多数的TCP/IP实现都在内核中直接支持Ping服务器—这种服务器不是一个用户进程**（在第6章中描述的两种ICMP查询服务，地址掩码和时间戳请求，也都是直接在内核中进行处理的）。

>回显请求与回显应答报文格式：

![image](https://user-images.githubusercontent.com/34849140/144731548-b9b54f79-42fd-434e-98aa-57800fab524b.png)

对于其他类型的ICMP查询报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣。

Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息。序列号从0开始，每发送一次新的回显请求就加1。ping程序打印出返回的每个分组的序列号，允许我们查看是否有分组丢失、失序或重复。IP是一种最好的数据报传递服务，因此这三个条件都有可能发生。

#### 7.1.1 LAN输出

>在局域网上运行ping程序，抓包结果如下，显然用的是ICMP协议：

![image](https://user-images.githubusercontent.com/34849140/144734278-5eec8ac4-46f7-4422-83bf-f2774842ac99.png)

#### 7.1.2 WAN输出(略)

### 7.2 IP记录路由选项

ping程序为我们提供了查看IP记录路由（RR）选项的机会。大多数不同版本的ping程序都提供-R选项，以提供记录路由的功能。它使得ping程序在发送出去的IP数据报中设置IP RR选项（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都把它的IP地址放入选项字段中。**当数据报到达目的端时，IP地址清单应该复制到ICMP回显应答中**，这样返回途中所经过的路由器地址也被加入清单中。当ping程序收到回显应答时，它就打印出这份IP地址清单。

有个问题是IP首部中只有有限的空间来存放IP地址。IP首部中的首部长度字段只有4 bit，因此整个IP首部最长只能包括15个32 bit长的字（即60个字节）。由于IP首部固定长度为20字节，RR选项用去3个字节（下面我们再讨论），这样只剩下37个字节（60-20-3）来存放IP地址清单，也就是说只能存放9个IP地址。

>IP数据报中的RR选项的一般格式如图:

![image](https://user-images.githubusercontent.com/34849140/144739944-4928602a-4783-440e-85c2-b8a0fe515401.png)

- code是一个字节，指明IP选项的类型。对于RR选项来说，它的值为7。len是RR选项总字节长度，在这种情况下为39（尽管可以为RR选项设置比最大长度小的长度，但是ping程序总是提供39字节的选项字段，最多可以记录9个IP地址。
- ptr称作指针字段。它是一个基于1的指针，指向存放下一个IP地址的位置。它的最小值为4，指向存放第一个IP地址的位置。随着每个IP地址存入清单，ptr的值分别为8，12，16，最大到36。当记录下9个IP地址后，ptr的值为40，表示清单已满。
- 当路由器在清单中记录IP地址时，它应该记录哪个地址呢？是入口地址还是出口地址？为此，RFC 791指定路由器记录出口IP地址。当原始主机（运行ping程序的主机）收到带有RR选项的ICMP回显应答时，它也要把它的入口IP地址放入清单中。

#### 7.2.1 通常的例子

>EXAMPLE

在主机svr4上运行ping程序到主机slip。一个中间路由器(bsdi)将处理这个数据报。下面是svr4的输出结果：

![image](https://user-images.githubusercontent.com/34849140/144740303-3314ba50-4c0a-455d-b8b1-a0ba1492012b.png)

分组所经过的四站如下图所示（每个方向各有两站），每一站都把自己的IP地址加入RR清单。

![image](https://user-images.githubusercontent.com/34849140/144740364-483e65f1-3e46-492f-b4cf-455f24ce1d58.png)

#### 7.2.1 异常的输出

下面的例子是作者观察到的，把它作为第9章讨论ICMP间接报文的起点。在子网140.252.1上ping主机aix（在主机sun上通过拨号SLIP连接可以访问），并带有记录路由选项。在slip主机上运行有如下输出结果：

![image](https://user-images.githubusercontent.com/34849140/144743158-f27379bd-43d9-464f-ac36-72e6847a0b5f.png)

这次选择slip来运行ping，观察RR清单中所有的9个IP地址。在输出中令人感到疑惑的是，为什么传出的数据报（ICMP回显请求）直接从netb传到aix，而返回的数据报（ICMP回显应答）却从aix开始经路由器gateway再到netb？这里看到的正是下面将要描述的`IP选路的一个特点`。数据报经过的路由如图所示：

![image](https://user-images.githubusercontent.com/34849140/144743220-0dcc6bb9-e5e5-4a5a-8f45-487ef23cd4a0.png)

问题是aix不知道要把目的地为子网140.252.13的IP数据报发到主机netb上。相反，aix在它的路由表中有一个默认项，它指明当没有明确某个目的主机的路由时，就把所有的数据报发往默认项指定的路由器gateway。`路由器gateway比子网140.252.1上的任何主机都具备更强的选路能力。`

这里没有应答的一个问题是**为什么gateway不直接发送ICMP报文重定向到aix**（9.5节），以更新它的路由表？由于某种原因，重定向并没有产生。但是如果我们用Telnet登录到aix上的daytime服务器，ICMP就会产生重定向，因而它在aix上的路由表也随之更新。如果接着执行ping程序并带有记录路由选项，其路由显示表明数据报从netb到aix，然后返回netb，而不再经过路由器gateway。在9.5节中将更详细地讨论`ICMP重定向`的问题。

### 7.3 IP时间戳选项（略）

### 8. Traceroute程序

由Van Jacobson编写的Traceroute程序是一个能更深入探索TCP/IP协议的方便可用的工具。尽管不能保证从源端发往目的端的两份连续的IP数据报具有相同的路由，但是大多数情况下是这样的。Traceroute程序可以让我们**看到IP数据报从一台主机传到另一台主机所经过的路由**。Traceroute程序还可以让我们使用IP源路由选项。

上一章节提到IP记录路由选项（RR）。为什么不使用这个选项而另外开发一个新的应用程序？有三个方面的原因：
- 原先并不是所有的路由器都支持记录路由选项
- 记录路由一般是单向的选项。发送端设置了该选项，那么接收端不得不从收到的IP首部中提取出所有的信息，然后全部返回给发送端。在7.2节中，我们看到大多数Ping服务器的实现（内核中的ICMP回显应答功能）把接收到的RR清单返回，但是这样使得记录下来的IP地址翻了一番（一来一回）。这样做会受到一些限制，这一点我们在下一段讨论（Traceroute程序只需要目的端运行一个UDP模块—其他不需要任何特殊的服务器应用程序）。
- 最后一个原因也是最主要的原因是，IP首部中留给选项的空间有限，不能存放当前大多数的路径。在IP首部选项字段中最多只能存放9个IP地址。

Traceroute程序使用ICMP报文和IP首部中的TTL字段（生存周期）。TTL字段是由发送端初始设置一个8bit字段。推荐的初始值由分配数字RFC指定，当前值为64。较老版本的系统经常初始化为15或32。我们从第7章中的一些ping程序例子中可以看出，发送ICM P回显应答时经常把TTL设为最大值255。

TTL字段的目的是防止数据报在选路时无休止地在网络中流动。例如，当路由器瘫痪或者两个路由器之间的连接丢失时，`选路协议`有时会去检测丢失的路由并一直进行下去。在这段时间内，数据报可能在循环回路被终止。TTL字段就是在这些循环传递的数据报上加上一个生存上限。

当路由器收到一份IP数据报，如果其TTL字段是0或1，则路由器不转发该数据报，而是该数据报丢弃，并**给信源机发一份ICMP“超时”信息**。Traceroute程序的关键在于包含这份ICMP信息的IP报文的信源地址是该路由器的IP地址。

我们现在可以猜想一下Traceroute程序的操作过程。**它发送一份TTL字段为1的IP数据报给目的主机。处理这份数据报的第一个路由器将TTL值减1，丢弃该数据报，并发回一份超时ICMP报文**。这样就得到了该路径中的第一个路由器的地址。然后Traceroute程序发送一份TTL值为2的数据报，这样我们就可以得到第二个路由器的地址。继续这个过程直至该数据报到达目的主机。但是目的主机哪怕接收到TTL值为1的IP数据报，也不会丢弃该数据报并产生一份超时ICMP报文，这是因为数据报已经到达其最终目的地。那么我们该如何判断是否已经到达目的主机了呢？
Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于30 000），使目的主机的任何一个应用程序都不可能使用该端口。因为，**当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”错误（见6.5节）的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。**

#### 8.1 局域网输出

>我们将使用从svr4到slip，经路由器bsdi的简单互联网（如图4.5）。bsdi和slip之间是9600 b/s的SLIP链路

![image](https://user-images.githubusercontent.com/34849140/144748663-77b3525a-b8a2-4edc-93ff-05b703683e91.png)

输出的第1个无标号行给出了目的主机名和其IP地址，指出traceroute程序最大的TTL字段值为30。40字节的数据报包含20字节IP首部、8字节的UDP首部和12字节的用户数据（12字节的用户数据包含每发一个数据报就加1的序列号，送出TTL的副本以及发送数据报的时间）。

输出的后面两行以TTL开始，接下来是主机或路由器名以及其IP地址。对于每个TTL值，发送3份数据报。每接收到一份ICMP报文，就计算并打印出往返时间。如果在5秒种内仍未收到3份数据报的任意一份的响应，则打印一个星号，并发送下一份数据报。在上述输出结果中，TTL字段为1的前3份数据报的ICMP报文分别在20 ms、10 ms和10 ms收到。TTL字段为2的3份数据报的ICMP报文则在120 ms后收到。由于TTL字段为2到达最终目的主机，因此程序就此停止。

图8-1给出了tcpdump的运行输出结果。正如我们所预想的那样，第1个发往bsdi的探测数据报的往返时间是20 ms、而后面两个数据报往返时间是10 ms的原因是发生了一次ARP交换。tcpdump结果证实了确实是这种情况。

![image](https://user-images.githubusercontent.com/34849140/144753852-bd3f1999-4d34-459f-a53c-e722c18ae872.png)

bsdi路由器将TTL值减到0，因此我们预计它将发回“传送超时”的ICMP报文。即使这份被丢弃的IP报文发送往slip，路由器也会发回ICMP报文。
第9 ~ 1 4行对应于TTL为2的3份数据报。这3份报文到达最终目的主机，并产生一份ICMP端口不可达报文。

有两种不同的ICMP“超时”报文（见6.1节），它们的ICMP报文中code字段不同。下图给出了这种ICMP差错报文的格式。

![image](https://user-images.githubusercontent.com/34849140/144754087-892991f6-5ff3-473c-bdba-33489be8a3ab.png)

我们所讨论的ICMP报文是在TTL值等于0时产生的，其code字段为0。主机在组装分片时可能发生超时，这时，它将发送一份“组装报文超时”的ICMP报文（我们将在11.5节讨论分片和组装）。这种差错报文将code字段置1。

关于traceroute程序，还有一些必须指出的事项：
- 并不能保证现在的路由也是将来所要采用的路由，甚至两份连续的IP数据报都可能采用不同的路由。如果在运行程序时，路由发生改变，就会观察到这种变化，这是因为对于一个给定的TTL，如果其路由发生变化，traceroute程序将打印出新的IP地址。
- 不能保证ICMP报文的路由与traceroute程序发送的UDP数据报采用同一路由。
- 返回的ICMP报文中的信源IP地址是UDP数据报到达的路由器接口的IP地址。这与IP记录路由选项（7.2节）不同，记录的IP地址指的是发送接口地址。

#### 8.2 广域网输出（略）

![image](https://user-images.githubusercontent.com/34849140/145238499-b6f41255-0fbb-429d-b5f1-8a39f5919afc.png)

#### 8.3 IP源站选路选项

>通常IP路由是动态的，即每个路由器都要判断数据报下面该转发到哪个路由器。应用程序对此不进行控制，而且通常也并不关心路由。它采用类似Traceroute程序的工具来发现
实际的路由。

源站选路(source routing)的思想是由发送者指定路由。它可以采用以下两种形式：
- 严格的源路由选择。发送端指明IP数据报所必须采用的确切路由。如果一个路由器发现源路由所指定的下一个路由器不在其直接连接的网络上，那么它就返回一个“源站路由失败”的ICMP差错报文。
- 宽松的源站选路。发送端指明了一个数据报经过的IP地址清单，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器。

**具体细节以及例子略**

### 9. IP选路
>本章的主要的目的是了解单个IP层如何作出路由决策。在某个给定主机上运行何种路由协议，如何在相邻路由器上交换选路信息，以及选路协议是如何工作的，所有这些问题都是非常复杂的，其本身就可以用整本书来加以讨论。在第10章中，我们将简单讨论动态选路和选路信息协议RIP（Routing Information Protocol）。

![image](https://user-images.githubusercontent.com/34849140/145676681-6a4bcec0-585a-46f1-942d-bb720c629e23.png)

#### 9.1 选路的原理

开始讨论IP选路之前，首先要理解内核是如何维护路由表的。路由表中包含的信息决定了IP层所做的所有决策。
在3.3节中，我们列出了IP搜索路由表的几个步骤：
- 搜索匹配的主机地址；
- 搜索匹配的网络地址；
- 搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为0）。

匹配主机地址步骤始终发生在匹配网络地址步骤之前。

IP层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。这区别于选路策略，它只是一组决定把哪些路由放入路由表的规则。**IP执行选路机制**，而路由守护程序则一般提供选路策略。

#### 9.1.1 简单路由表

>还是以图7-6为例子：

在主机svr4上，我们先执行带-r选项的netstat命令列出路由表，然后以-n选项再次执行该命令，以数字格式打印出IP地址：

![image](https://user-images.githubusercontent.com/34849140/145208469-6b1f997c-031b-4918-93da-a823f840a40c.png)

第1行说明，如果目的地是140.252.13.65（slip主机），那么网关（路由器）将把分组转发给140.252.13.35（bsdi）。这正是我们所期望的，因为主机slip通过SLIP链路与bsdi相连接，而bsdi与该主机在同一个以太网上。
对于一个给定的路由器，可以打印出五种不同的标志（flag）：
- U 该路由可以使用。
- G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。
- H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址：一个网络号，或者网络号与子网号的组合。
- D 该路由是由重定向报文创建的（9.5节）。
- M 该路由已被重定向报文修改（9.5节）。

以下是对这几个参数的详细解读：

- 标志G是非常重要的，因为由它区分了间接路由和直接路由（对于直接路由来说是不设置标志G的）。其区别在于，发往直接路由的分组中不但具有指明目的端的IP地址，还具有其链路层地址。当分组被发往一个间接路由时，IP地址指明的是最终的目的地，但是链路层地址指明的是网关（即下一站路由器）。在这个路由表例子中，有一个间接路由（设置了标志G），因此采用这一项路由的分组其IP地址是最终的目的地（140.252.13.65），但是其链路层地址必须对应于路由器140.252.13.35。
- 理解G和H标志之间的区别是很重要的。G标志区分了直接路由和间接路由，如上所述。但是H标志表明，目的地址（netstat命令输出第一行）是一个完整的主机地址。没有设置H标志说明目的地址是一个网络地址（主机号部分为0）。当为某个目的IP地址搜索路由表时，主机地址项必须与目的地址完全匹配，而网络地址项只需要匹配目的地址的网络号和子网号就可以了。
- 下一列（“use”）显示的是通过该路由发送的分组数。如果我们是这个路由的唯一用户，那么运行ping程序发送5个分组后，它的值将变为5。最后一列（interface）是本地接口的名字。
- 输出的第2行是环回接口（2.7节），它的名字始终为lo0。没有设置G标志，因为该路由不是一个网关。H标志说明目的地址（127.0.0.1）是一个主机地址，而不是一个网络地址。由于没有设置G标志，说明这是一个直接路由，***网关列给出的是外出IP地址。***
- 输出的第3行是默认路由。每个主机都有一个或多个默认路由。这一项表明，如果在表中没有找到特定的路由，就把分组发送到路由器140.252.13.33（sun主机）。这说明当前主机（svr4）利用这一个路由表项就可以通过Internet经路由器sun（及其SLIP链路）访问其他的系统。建立默认路由是一个功能很强的概念。该路由标志（UG）表明它是一个网关，这是我们所期望的。
- 最后一行是所在的以太网。H标志没有设置，说明目的地址（140.252.13.32）是一个网络地址，其主机地址部分设为0。事实上，是它的低5位设为0。由于这是一个直接路由（G标志没有被设置），***网关列指出的IP地址是外出地址。***

>主机路由表的复杂性取决于主机所在网络的拓扑结构：

- 最简单的（也是最不令人感兴趣的）情况是主机根本没有与任何网络相连。TCP/IP协议仍然能用于这样的主机，但是只能与自己本身通信！这种情况下的路由表只包含环回接口一项。
- 接下来的情况是主机连在一个局域网上，只能访问局域网上的主机。这时路由表包含两项：一项是环回接口，另一项是局域网（如以太网）。
- 如果主机能够通过单个路由器访问其他网络（如Internet）时，那么就要进行下一步。一般情况下增加一个默认表项指向该路由器。
- 如果要新增其他的特定主机或网络路由，那么就要进行最后一步。在我们的例子中，到主机slip的路由要通过路由器bsdi就是这样的例子。

我们根据上述IP操作的步骤使用这个路由表为主机svr4上的一些分组例子选择路由。
- 假定目的地址是主机sun，140.252.13.33。首先进行主机地址的匹配。路由表中的两个主机地址表项（slip和localhost）均不匹配，接着进行网络地址匹配。这一次匹配成功，找到表项140.252.13.32（网络号和子网号都相同），因此使用emd0接口。这是一个直接路由，因此链路层地址将是目的端的地址。
- 假定目的地址是主机slip，140.252.13.65。首先在路由表搜索主机地址，并找到一个匹配地址。这是一个间接路由，因此目的端的IP地址仍然是140.252.13.65，但是链路层地址必须是网关140.252.13.35的链路层地址，其接口名为emd0。
- 这一次我们通过Internet给主机aw.com（192.207.117.2）发送一份数据报。首先在路由表中搜索主机地址，失败后进行网络地址匹配。最后成功地找到默认表项。该路由是一个间接路由，通过网关140.252.13.33，并使用接口名为emd0。

#### 9.1.2 初始化路由表

每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。***对于点对点链路和环回接口来说，路由是到达主机（例如，设置H标志）。对于广播接口来说，如以太网，路由是到达网络。***

到达主机或网络的路由如果不是直接相连的，那么就必须加入路由表。一个常用的方法是在系统引导时显式地在初始化文件中运行route命令。在主机svr4上，我们运行下面两个命令来添加路由表中的表项：

```shell
route add default sun 1
route add slip bsdi 1
``` 

第3个参数（default和slip）代表目的端，第4个参数代表网关（路由器），最后一个参数代表路由的度量(metric)。route命令在度量值大于0时要为该路由设置G标志，否则，当耗费值为0时就不设置G标志。

一些系统允许在某个文件中指定默认的路由器，如/etc/defaultrouter。于是在每次重新启动系统时都要在路由表中加入该默认项。

初始化路由表的其他方法是**运行路由守护程序**（第10章）或者用较新的**路由器发现协议（9.5 节）**。

#### 9.1.3 较复杂的路由表

在我们的子网上，主机sun是所有主机的默认路由器，因为它有拨号SLIP链路连接到Internet上。

![image](https://user-images.githubusercontent.com/34849140/145226006-708184a2-c821-4600-8426-16cc6c46732d.png)

前两项与主机svr4的前两项一致：通过路由器bsdi到达slip的特定主机路由，以及环回路由。

第3行是新加的。这是一个直接到达主机的路由(没有设置G标志，但设置了H标志)，对应于点对点的链路，即SLIP接口。如果我们把它与ifconfig命令的输出进行比较：

```shell
sun % ifconfig sl0
sl0: flags=1051<U P , P O I N T O P O I N T , R U N N I N G >
     inet 140.252.1.29 --> 140.252.1.183 netmask ffffff00
```

可以发现路由表中的目的地址就是点对点链路的另一端(即路由器netb), 网关地址为外出接口的本地IP地址( 140.252.1.29) (前面已经说过, netstat为直接路由打印出来的网关地址就是本地接口所用的IP地址)。默认的路由表项是一个到达网络的间接路由(设置了G标志，但没有设置H标志)，这正是我们所希望的。网关地址是路由器的地址(140.252.1.183，SLIP链路的另一端), 而不是SLIP链路的本地IP地址(140.252.1.29)。其原因还是因为是间接路由，不是直接路由。

还应该指出的是，netstat输出的第3和第4行(接口名为sl0)由SLIP软件在启动时创建，并在关闭时删除.

#### 9.1.4 没有到达目的地的路由

>如果路由表中没有默认项，而又没有找到匹配项，这时会发生什么情况呢？

结果取决于该IP数据报是由主机产生的还是被转发的（例如，我们就充当一个路由器）。如果数据报是由本地主机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”。如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文。下一节将讨论这种差错。

### 9.2 ICMP主机与网络不可达差错

当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文。

我们在上一节通过在路由器sun上运行netstat命令可以看到，当接通SLIP链路启动时就要在路由表中增加一项使用SLIP链路的表项，而当断开SLIP链路时则删除该表项。这说明当SLIP链路断开时，sun的路由表中就没有默认项了。但是我们不想改变网络上其他主机的路由表，即同时删除它们的默认路由。相反，对于sun不能转发的分组，我们对它产生的ICMP主机不可达差错报文进行计数。

在主机svr4上运行ping程序就可以看到这一点，它在拨号SLIP链路的另一端（拨号链路已被断开）：

![image](https://user-images.githubusercontent.com/34849140/145425609-3f5aaac5-449b-4321-b58a-a55960e292d7.png)

在主机bsdi上运行tcpdump命令的输出如图所示：

![image](https://user-images.githubusercontent.com/34849140/145425856-38993328-6813-4178-ae9c-7ecefe9ad73f.png)

当路由器sun发现找不到能到达主机gemini的路由时，它就响应一个主机不可达的回显请求报文。

### 9.3 转发或不转发 - 略

### 9.4 ICMP重定向差错

>当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给I P数据报的发送端。这在概念上是很简单的，正如图所示的那样。只有当主机可以选择路由器发送分组的情况下，我们才可能看到ICMP重定向报文.

- 我们假定主机发送一份IP数据报给R1。这种选路决策经常发生，因为R1是该主机的默认路由。
- R1收到数据报并且检查它的路由表，发现R 2是发送该数据报的下一站。当它把数据报发送给R2时，R1检测到它正在发送的接口与数据报到达接口是相同的（即主机和两个路由器所在的LAN）。这样就给路由器发送重定向报文给原始发送端提供了线索。
- R1发送一份ICMP重定向报文给主机，告诉它以后把数据报发送给R2而不是R1。

![image](https://user-images.githubusercontent.com/34849140/145432696-9d32366d-b62f-4f02-ac04-fffca0b0ebe1.png)

重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。主机启动时路由表中可以只有一个默认表项。一旦默认路由发生差错，默认路由器将通知它进行重定向，并允许主机对路由表作相应的改动。ICMP重定向允许TCP/IP主机在进行选路时不需要具备智能特性，而把所有的智能特性放在路由器端。

>EXAMPLE ONE:

![image](https://user-images.githubusercontent.com/34849140/145591529-13aca8b1-b6a4-4332-a035-07ab7575a322.png)

可以在我们的网络上观察到ICMP重定向的操作过程。尽管在拓扑图中只画出了三台主机（aix , solaris和gemini）和两台路由器（gateway和netb），但是整个网络有超过150台主机和10台另外的路由器。大多数的主机都把gateway指定为默认路由器，因为它提供了Internet的入口。

子网140.252.1上的主机是如何访问作者所在子网（图中底下的四台主机）的呢？首先，如果在SLIP链路的一端只有一台主机，那么就要使用代理ARP（4.6节讲过）。这意味着位于拓扑图顶部的子网（140.252.1）中的主机不需要其他特殊条件就可以访问主机sun（140.252.1.29）。位于netb上的代理ARP软件处理这些事情。

但是，当网络位于SLIP链路的另一端时，就要涉及到选路了。**一个办法是让所有的主机和路由器都知道路由器netb是网络140.252.13的网关。这可以在每个主机的路由表中设置静态路由**，或者在每个主机上运行守护程序来实现。**另一个更简单的办法（也是实际采用的方法）是利用ICMP重定向报文来实现**。

在位于网络顶部的主机solaris上运行ping程序到主机bsdi(140.252.13.35)。由于子网号不相同，代理ARP不能使用。假定没有安装静态路由，发送的第一个分组将采用到路由器gateway的默认路由。下面是我们运行ping程序之前的路由表(224.0.0.0所在的表项是IP广播地址。将在第12章讨论)：

![image](https://user-images.githubusercontent.com/34849140/145593002-9ec96082-accd-49fb-9117-71dd3bc299c5.png)

如果为ping程序指定-v选项，可以看到主机接收到的任何ICMP报文。我们需要指定该选项以观察发送的重定向报文。

![image](https://user-images.githubusercontent.com/34849140/145599593-6b05fe0e-60c0-433c-9e6d-d0a82b6ccfbe.png)

在收到ping程序的第一个响应之前，主机先收到一份来自默认路由器gateway发来的ICMP重定向报文。如果这时查看路由表，就会发现已经插入了一个到主机bsdi的新路由（该表项如以下黑体字所示）:

![image](https://user-images.githubusercontent.com/34849140/145600007-40f1bc06-7093-4a80-a240-40ba04758d75.png)

这是我们第一次看到**D标志，表示该路由是被ICMP重定向报文创建的**。G标志说明这是一份到达gateway(netb）的间接路由，H标志则说明这是一个主机路由（正如我们期望的那样），而不是一个网络路由。

由于这是一个被主机重定向报文增加的主机路由，因此它只处理到达主机bsdi的报文。如果我们接着访问主机svr4，那么就要产生另一个ICMP重定向报文，创建另一个主机路由。类似地，访问主机slip也创建另一个主机路由。***位于子网上的三台主机（bsdi,svr4和slip）还可以由一个指向路由器sun的网络路由来进行处理***。但是ICMP重定向报文创建的是主机路由，而不是网络路由，这是因为在本例中，产生ICMP重定向报文的路由器并不知道位于140.252.13网络上的子网信息。

>EXAMPLE TWO: 重定向报文的更多细节（略）

### 9.5 ICMP路由器发现报文

在本章前面已提到过一种初始化路由表的方法，即在配置文件中指定静态路由。这种方法经常用来设置默认路由。另一种新的方法是利用ICMP路由器通告和请求报文。

一般认为，主机在引导以后要广播或多播传送一份路由器请求报文。一台或更多台路由器响应一份路由器通告报文。另外，路由器定期地广播或多播传送它们的路由器通告报文，允许每个正在监听的主机相应地更新它们的路由表。

RFC 1256确定了这两种ICMP报文的格式。ICMP路由器请求报文的格式如图9-6所示。ICMP路由器通告报文的格式如图9-7所示：

![image](https://user-images.githubusercontent.com/34849140/145670657-ded2f8b1-28c6-4e90-86e5-7bd7c2455b43.png)

![image](https://user-images.githubusercontent.com/34849140/145670673-e151a392-03cb-430a-8e8c-20bd315a0729.png)

路由器在一份报文中可以通告多个地址。地址数指的是报文中所含的地址数。地址项大小指的是每个路由器地址32 bit字的数目，始终为2。生存期指的是通告地址有效的时间（秒数）。

接下来是一对或多对IP地址和优先级。IP地址必须是发送路由器的某个地址。优先级是一个有符号的32 bit整数，指出该IP地址作为默认路由器地址的优先等级，这是与子网上的其他路由器相比较而言的。值越大说明优先级越高。优先级为0x80000000说明对应的地址不能作为默认路由器地址使用，尽管它也包含中通告报文中。优先级的默认值一般为0。

### 9.5.1 路由器操作

当路由器启动时，它定期在所有广播或多播传送接口上发送通告报文。准确地说，这些通告 报文不是定期发送的，而是随机传送的，以减小与子网上其他路由器发生冲突的概率。一般每两次通告间隔450秒和600秒。一份给定的通告报文默认生命周期是30分钟。使用生命周期域的另一个时机是当路由器上的某个接口被关闭时。在这种情况下，路由器可以在该接口上发送最后一份通告报文，并把生命周期值设为0。

除了定期发送主动提供的通告报文以外，路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。如果子网上有多台路由器，由系统管理员为每个路由器设置优先等级。例如，主默认路由器就要比备份路由器具有更高的优先级。

### 9.5.2 主机操作

主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。

主机也监听来自相邻路由器的请求报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。

只要有一般的默认路由器，该路由器就会每隔10分钟发送通告报文，报文的生命周期是30分钟。这说明主机的默认表项是不会超时的，即使错过一份或两份通告报文。

### 10. 动态选路协议

### 10.1 引言

在前面各章中，我们讨论了静态选路。在配置接口时，以默认方式生成路由表项（对于直接连接的接口），并通过route命令增加表项（通常从系统自引导程序文件），或是通过ICMP重定向生成表项（通常是在默认方式出错的情况下）。在网络很小，且与其他网络只有单个连接点且没有多余路由时（若主路由失败，可以使用备用路由），采用这种方法是可行的。如果上述三种情况不能全部满足，通常使用动态选路。

**本章讨论动态选路协议，它用于路由器间的通信。我们主要讨论RIP，即选路信息协议(Routing Infromation Protocol)，大多数TCP/IP实现都提供这个应用广泛的协议**。然后讨论两种新的选路协议，OSPF和BGP。本章的最后研究一种名叫**无分类域间选路的新的选路技术，现在Internet上正在开始采用该协议以保持B类网络的数量**。

动态选路仍然是一个网间互连的研究热点。对使用的选路协议和运行的路由守护程序进行选择，是一项复杂的工作。[Perlman 1992]提供了许多细节。

### 10.2 动态选路

当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。路由器之间必须采用选路协议进行通信，这样的选路协议有很多种。**路由器上有一个进程称为路由守护程序（routing daemon），它运行选路协议，并与其相邻的一些路由器进行通信**。正如图9-1所示，路由守护程序根据它从相邻路由器接收到的信息，**更新内核中的路由表**。

动态选路并不改变我们在9.2节中所描述的内核在IP层的选路方式。这种选路方式称为选路机制（routing mechanism）。内核搜索路由表，查找主机路由、网络路由以及默认路由的方式并没有改变。仅仅是放置到路由表中的信息改变了—当路由随时间变化时，**路由是由路由守护程序动态地增加或删除，而不是来自于自引导程序文件中的route命令**。

动态选路并不改变我们在9.2节中所描述的内核在IP层的选路方式。这种选路方式称为选路机制（routing mechanism）。内核搜索路由表，查找主机路由、网络路由以及默认路由的方式并没有改变。仅仅是放置到路由表中的信息改变了—当路由随时间变化时，路由是由路由守护程序动态地增加或删除，而不是来自于自引导程序文件中的route命令。

在像Internet这样的系统中，目前采用了许多不同的选路协议。Internet是以一组自治系统(AS，Autonomous System)的方式组织的，每个自治系统通常由单个实体管理。常常将一个公司或大学校园定义为一个自治系统。NSFNET的Internet骨干网形成一个自治系统，这是因为骨干网中的所有路由器都在单个的管理控制之下。每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为**内部网关协议IGP（Interior Gateway Protocol）或域内选路协议（intradomain routing protocol）**。最常用的IGP是选路信息协议RIP。一种新的**IGP是开放最短路径优先OSPF（Open Shortest Path First）协议**。它意在取代RIP。

外部网关协议EGP（Exterier Gateway Protocol）或域内选路协议的分隔选路协议用于不同自治系统之间的路由器。新近流行的EGP是边界网关协议（BGP）。

### 10.3 Unix选路守护程序

Unix系统上常常运行名为routed路由守护程序。几乎在所有的TCP/IP实现中都提供该程序。该程序只使用RIP进行通信，我们将在下一节中讨论该协议。这是一种用于小型到中型网络中的协议。

另一个程序是gated。IGP和EGP都支持它。[Fedor 1998]描述了早期开发的gated。图10-1对routed和两种不同版本的gated所支持的不同选路协议进行了比较。大多数运行路由守护程序的系统都可以运行routed，除非它们需要支持gated所支持的其他协议。

![image](https://user-images.githubusercontent.com/34849140/145678634-89008bb3-a2bf-4ee5-9059-8e822f3cf089.png)

### 10.4 RIP：选路信息协议

>本节对RIP进行了描述，这是因为它是最广为使用（也是最受攻击）的选路协议。对于RIP的正式描述文件是RFC 1058 [Hedrick 1988a]，但是该RFC是在该协议实现数年后才出现的。

#### 10.4.1 报文格式

RIP报文包含中在UDP数据报中，如下图所示（在第11章中对UDP进行更为详细的描述）：

![image](https://user-images.githubusercontent.com/34849140/145678899-a92c63d5-0ff3-4ef4-8bd9-297ccb7be407.png)

RIP报文格式：

![image](https://user-images.githubusercontent.com/34849140/145678986-9414192f-fb5c-4451-a428-a439dfd8e265.png)

命令字段为1表示请求，2表示应答。还有两个舍弃不用的命令（3和4），两个非正式的命令：轮询（5）和轮询表项（6）。请求表示要求其他系统发送其全部或部分路由表。应答则包含发送者全部或部分路由表。

版本字段通常为1，而第2版RIP（10.5节）将此字段设置为2。
紧跟在后面的20字节指定地址系列（address family）（对于IP地址来说，其值是2）、IP地址以及相应的度量。在本节的后面可以看出，RIP的度量是以跳计数的。

采用这种20字节格式的RIP报文可以通告多达25条路由。上限25是用来保证RIP报文的总长度为20×25 + 4 = 504，小于512字节。由于每个报文最多携带25个路由，因此为了发送整个路由表，经常需要多个报文。

#### 10.4.2 正常运行

让我们来看一下采用RIP协议的routed程序正常运行的结果。RIP常用的UDP端口号是520。

- 初始化：在启动一个路由守护程序时，它先判断启动了哪些接口，并在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。在点对点链路中，该请求是发送给其他终点的。如果网络支持广播的话，这种请求是以广播形式发送的。目的UDP端口号是520（这是其他路由器的路由守护程序端口号）。这种请求报文的命令字段为1，但地址系列字段设置为0，而度量字段设置为16。这是一种要求另一端完整路由表的特殊请求报文。
- 接收到请求。如果这个请求是刚才提到的特殊请求，那么路由器就将完整的路由表发送给请求者。否则，就处理请求中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量置为16（度量为16是一种称为“无穷大”的特殊值，它意味着没有到达目的的路由）。然后发回响应。
- 接收到响应。使响应生效，可能会更新路由表。可能会增加新表项，对已有的表项进行修改，或是将已有表项删除。
- 定期选路更新。每过30秒，所有或部分路由器会将其完整路由表发送给相邻路由器。发送路由表可以是广播形式的（如在以太网上），或是发送给点对点链路的其他终点的。
- 触发更新。每当一条路由的度量发生变化时，就对它进行更新。不需要发送完整路由表，而只需要发送那些发生变化的表项。

每条路由都有与之相关的定时器。如果运行RIP的系统发现一条路由在3分钟内未更新，就将该路由的度量设置成无穷大（16），并标注为删除。这意味着已经在6个30秒更新时间里没收到通告该路由的路由器的更新了。再过60秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。

#### 10.4.3 度量

RIP所使用的度量是以跳(hop)计算的。所有直接连接接口的跳数为1。考虑图10-4所示的路由器和网络。画出的4条虚线是广播RIP报文。

![image](https://user-images.githubusercontent.com/34849140/145681531-5453b833-120b-4b49-84f7-92a595584403.png)

路由器R1通过发送广播到N1通告它与N2之间的跳数是1（发送给N1的广播中通告它与N1之间的路由是无用的）。同时也通过发送广播给N2通告它与N1之间的跳数为1。同样，R2通告它与N2的度量为1，与N3的度量为1。
如果相邻路由器通告它与其他网络路由的跳数为1，那么我们与那个网络的度量就是2，这是因为为了发送报文到该网络，我们必须经过那个路由器。在我们的例子中，R2到N1的度量是2，与R1到N3的度量一样。
由于每个路由器都发送其路由表给邻站，因此，可以判断在同一个自治系统AS内到每个网络的路由。如果在该AS内从一个路由器到一个网络有多条路由，那么路由器将选择跳数最小的路由，而忽略其他路由。

跳数的最大值是15，这意味着RIP只能用在主机间最大跳数值为15的AS内。度量为16表示到无路由到达该IP地址。

#### 10.4.4 问题

这种方法看起来很简单，但它有一些缺陷。首先，RIP没有子网地址的概念。例如，如果标准的B类地址中16 bit的主机号不为0，那么RIP无法区分非零部分是一个子网号，或者是一个主机地址。有一些实现中通过接收到的RIP信息，来使用接口的网络掩码，而这有可能出错。

其次，在路由器或链路发生故障后，需要很长的一段时间才能稳定下来。这段时间通常需要几分钟。**在这段建立时间里，可能会发生路由环路。在实现RIP时，必须采用很多微妙的措施来防止路由环路的出现**，并使其尽快建立。

采用跳数作为路由度量忽略了其他一些应该考虑的因素。同时，度量最大值为15则限制了可以使用RIP的网络的大小。

#### 10.4.5 EXAMPLE ONE

我们将使用ripquery程序来查询一些路由器中的路由表，该程序可以从gated中得到。ripquery程序通过发送一个非正式请求（图1 0-3中命令字段为5的“poll”）给路由器，要求得到其完整的路由表。如果在5秒内未收到响应，则发送标准的RIP请求（command字段为1）（前面提到过的，将地址系列字段置为0，度量字段置为16的请求，要求其他路由器发送其完整路由表）。

图10-5给出了将从sun主机上查询其路由表的两个路由器。如果在主机sun上执行ripquery程序，以得到其下一站路由器netb的选路信息，那么可以得到下面的结果：

![image](https://user-images.githubusercontent.com/34849140/145682595-f788cbd6-085f-4e17-b7ee-a35e4b08f02e.png)

![image](https://user-images.githubusercontent.com/34849140/145682937-9f3fe8a0-d069-4d5e-ba19-e1604f936a8a.png)

正如我们所猜想的那样，netb告诉我们子网的度量为1。另外，与netb相连的位于机端的以太网（140.252.1.0）的metric也是1（-n参数表示直接打印IP地址而不需要去查看其域名）。在本例中，将netb配置成认为所有位于140.252.13子网的主机都与其直接相连—即，netb并不知道哪些主机真正与140.252.13子网相连。***由于与140.252.13子网只有一个连接点，因此，通告每个主机的度量实际上没有太大意义***。

图10-6给出了使用tcpdump交换的报文。采用- i s10选项指定SLIP接口。

第1个请求发出一个RIP轮询命令（第1行）。这个请求在5秒后超时，发出一个常规的RIP请求（第2行）。第1行和第2行最后的24表示请求报文的长度：4个字节的RIP首部（包括命令和版本），然后是单个20字节的地址和度量。

第3行是第一个应答报文。该行最后的25表示包含了25个地址和度量对，我们在前面已经计算过，其字节数为504。这是上面的ripquery程序所打印出来的结果。我们为tcpdump程序指定- s600选项，以让它从网络中读取600个字节。这样，它可以接收整个UDP数据报（而不是报文的前半部），然后打印出RIP响应的内容。该输出结果省略了。

![image](https://user-images.githubusercontent.com/34849140/145682963-d7bb7255-3085-4feb-a88d-2a37bf1c2668.png)

第4行是来自路由器的第二个响应报文，它包含后面的12个地址和度量对。可以计算出该报文的长度为12×20 + 4=244，这正是ripquery程序所打印出来的结果。如果越过netb路由器，到gateway，那么可以预测到我们子网（140.252.13.0）的度量为2。可以运行下面的命令来进行验证：

![image](https://user-images.githubusercontent.com/34849140/145683038-70e616af-bf37-44d0-ab2d-8c53e3660a88.png)

这里，位于图10 - 5上面的以太网（140.252.1.0）的度量依然是1，这是因为该以太网直接与gateway和netb相连。而我们的子网140.252.13.0正如预想的一样，其度量为2。

#### 10.4.6 EXAMPLE TWO

现在察看以太网上所有非主动请求的RIP更新，以看一看RIP定期给其邻站发送的信息。图10 - 7是noao.edu网络的多种排列情况。为了简化，我们不用本文其他地方所采用的路由器表示方式，而以Rn来代表路由器，其中n是子网号。以虚线表示点对点链路，并给出了这些链路对端的IP地址。

![image](https://user-images.githubusercontent.com/34849140/145683141-d9134044-0584-40a9-aa62-fcebb3fcc75f.png)

在主机solaris上运行Solaris 2.x的snoop程序，它与tcpdump相类似。我们可以在不需要超用户权限的条件下运行该程序，但它只捕获广播报文、多播报文以及发送给主机的报文。图10 - 8给出了在60秒内所捕获的报文。

-P标志以非混杂模式捕获报文，-tr打印出相应的时戳，而udp port 520只捕获信源或信宿端口号为520的UDP数据报。

![image](https://user-images.githubusercontent.com/34849140/145683419-9b5d081e-ef43-4908-9e83-d043cfd436b5.png)

来自R6、R4、R2、R7、R8和R3的前6个报文，每个报文只通告一个网络。查看这些报文，可以发现R2通告前往140.252.6.0的跳数为1的一条路由，R4通告前往140.252.4.0的跳数为1的一条路由，等等。

但是，gateway路由器却通告了15条路由。我们可以通过运行snoop程序时加上-v参数来查看RIP报文的全部内容（这个标志输出全部报文的全部内容：以太网首部、IP首部、UDP首部以及RIP报文。我们只保留了RIP信息而删除了其他信息）。图10-9给出了输出结果。

把这些子网140.252.1上通告报文经过的路由与图10 - 7中的拓扑结构进行比较。使人迷惑不解的一个问题是为什么图10-8输出结果中，R10通告其有4个网络而在图10-7中显示的只有3个。如果查看带snoop的RIP报文，就会得到以下通告路由：

```shell
RIP：Address Metric
RIP: 140.251.0.0 16 (not reachable)
RIP: 140.252.9.0 1
RIP: 140.252.10.0 1
RIP: 140.252.11.0 1
```

前往B类网络140.251的路由是假的，不应该通告它（它属于其他机构而不是noao.edu）。图10-8中，对于R10发送的RIP报文，snoop输出“BROADCAST”符号，它表示目的IP地址是有限的广播地址255.255.255.255（12.2节），而不是其他路由器用来指向子网的广播地址（140.252.1.255）。

![image](https://user-images.githubusercontent.com/34849140/145683592-e565e8d5-2dd0-4d69-ac56-7c15b392ba47.png)

### 10.5 OSPF：开放最短路径优先(除RIP外的另一个内部网关协议)

>OSPF是除RIP外的另一个内部网关协议。它克服了RIP的所有限制。

与采用距离向量的RIP协议不同的是，OSPF是一个链路状态协议。距离向量的意思是，RIP发送的报文包含一个距离向量（跳数）。每个路由器都根据它所接收到邻站的这些距离向量来更新自己的路由表。

在一个链路状态协议中，路由器并不与其邻站交换距离信息。它采用的是每个路由器主动地测试与其邻站相连链路的状态，将这些信息发送给它的其他邻站，而邻站将这些信息在自治系统中传播出去。每个路由器接收这些链路状态信息，并建立起完整的路由表。从实际角度来看，二者的不同点是链路状态协议总是比距离向量协议收敛更快。收敛的意思是在路由发生变化后，例如在路由器关闭或链路出故障后，可以稳定下来。

OSPF与RIP（以及其他选路协议）的不同点在于，OSPF直接使用IP。也就是说，它并不使用UDP或TCP。对于IP首部的protocol字段，OSPF有其自己的值。

OSPF还有着一些优于RIP的特点：

- OSPF可以对每个I P服务类型（图3-2）计算各自的路由集。这意味着对于任何目的，可以有多个路由表表项，每个表项对应着一个IP服务类型。
- 给每个接口指派一个无维数的费用。可以通过吞吐率、往返时间、可靠性或其他性能来进行指派。可以给每个IP服务类型指派一个单独的费用。
- 当对同一个目的地址存在着多个相同费用的路由时，OSPF在这些路由上平均分配流量。我们称之为流量平衡。
- OSPF支持子网：子网掩码与每个通告路由相连。这样就允许将一个任何类型的IP地址分割成多个不同大小的子网（我们在3.7节中给出了这样的一个例子，称之为变长度子网）。到一个主机的路由是通过全1子网掩码进行通告的。默认路由是以IP地址为0.0.0.0、网络掩码为全0进行通告的。
- 路由器之间的点对点链路不需要每端都有一个IP地址，我们称之为无编号网络。这样可以节省IP地址—现在非常紧缺的一种资源。
- 采用了一种简单鉴别机制。可以采用类似于RIP-2机制（10.5节）的方法指定一个明文口令。
- OSPF采用多播（第12章），而不是广播形式，以减少不参与OSPF的系统负载。

### 10.6 BGP：边界网关协议

BGP是一种不同自治系统的路由器之间进行通信的外部网关协议。BGP是ARPANET所使用的老EGP的取代品。

BGP系统与其他BGP系统之间交换网络可到达信息。这些信息包括数据到达这些网络所必须经过的自治系统AS中的所有路径。这些信息足以构造一幅自治系统连接图。然后，可以根据连接图删除选路环，制订选路策略。

首先，我们将一个自治系统中的I P数据报分成本地流量和通过流量。在自治系统中，本地流量是起始或终止于该自治系统的流量。也就是说，其信源IP地址或信宿IP地址所指定的主机位于该自治系统中。其他的流量则称为通过流量。**在Internet中使用BGP的一个目的就是减少通过流量**。

可以将自治系统分为以下几种类型：
1) 残桩自治系统(stub AS)，它与其他自治系统只有单个连接。stub AS只有本地流量。
2) 多接口自治系统(multihomed AS)，它与其他自治系统有多个连接，但拒绝传送通过流量。
3) 转送自治系统(transit AS)，它与其他自治系统有多个连接，在一些策略准则之下，它可以传送本地流量和通过流量。

这样，可以将Internet的总拓扑结构看成是由一些残桩自治系统、多接口自治系统以及转送自治系统的任意互连。残桩自治系统和多接口自治系统不需要使用BGP——它们通过运行EGP在自治系统之间交换可到达信息。

BGP允许使用基于策略的选路。由自治系统管理员制订策略，并通过配置文件将策略指定给BGP。制订策略并不是协议的一部分，但指定策略允许BGP实现在存在多个可选路径时选择路径，并控制信息的重发送。

BGP与RIP和OSPF的不同之处在于BGP使用TCP作为其传输层协议。两个运行BGP的系统之间建立一条TCP连接，然后交换整个BGP路由表。从这个时候开始，在路由表发生变化时，再发送更新信号。BGP通过定期发送keepalive报文给其邻站来检测TCP连接对端的链路或主机失败。两个报文之间的时间间隔建议值为30秒。

### 10.7 CIDR：无类型域间选路(一种减少Internet路由表大小的技术)

在第3章中，我们指出了B类地址的缺乏，因此现在的多个网络站点只能采用多个C类网络号，而不采用单个B类网络号。尽管分配这些C类地址解决了一个问题（B类地址的缺乏），但它却**带来了另一个问题：每个C类网络都需要一个路由表表项。无类型域间选路（CIDR）是一个防止Internet路由表膨胀的方法，它也称为超网（supernetting）**。

CIDR的基本观点是采用一种分配多个IP地址的方式，使其能够将路由表中的许多表项总和(summarization)成更少的数目。例如，如果给单个站点分配16个C类地址，以一种可以用总和的方式来分配这16个地址，这样，所有这16个地址可以参照Internet上的单个路由表表项。同时，如果有8个不同的站点是通过同一个Internet服务提供商的同一个连接点接入Internet的，且这8个站点分配的8个不同IP地址可以进行总和，那么，对于这8个站点，在Internet上，只需要单个路由表表项。

要使用这种总和，必须满足以下三种特性：
- 为进行选路要对多个IP地址进行总和时，这些I P地址必须具有相同的高位地址比特。
- 路由表和选路算法必须扩展成根据32 bit IP地址和32 bit掩码做出选路决策。
- 必须扩展选路协议使其除了32 bit地址外，还要有32 bit掩码。OSPF（10.6节）和RIP-2（10.5节）都能够携带第4版BGP（边际网关协议）所提出的32 bit掩码。

例如，RFC 1466 [Gerich 1993] 建议欧洲新的C类地址的范围是194.0.0.0～195.255.255.25 。以16进制表示，这些地址的范围是0xc2000000～0xc3ffffff。它代表了65536个不同的C类网络号，但它们地址的高7bit是相同的。在欧洲以外的国家里，可以采用IP地址为0xc2000000和32 bit 0xfe000000 (254.0.0.0) 为掩码的单个路由表表项来对所有这些65536个C类网络号选路到单个点上。C类地址的后面各比特位（即在194或195后面各比特）也可以进行层次分配，例如以国家或服务提供商分配，以允许对在欧洲路由器之间使用除了这32 bit掩码的高7 bit外的其他比特进行概括。

CIDR同时还使用一种技术，使最佳匹配总是最长的匹配：即在32 bit掩码中，它具有最大值。我们继续采用上一段中所用的例子，欧洲的一个服务提供商可能会采用一个与其他欧洲服务提供商不同的接入点。如果给该提供商分配的地址组是从194.0.16.0到194.0.31.255 (16个C类网络号)，那么可能只有这些网络的路由表项的IP地址是194.0.16.0，掩码为255.255.240.0 (0xfffff000)。发往194.0.22.1地址的数据报将同时与这个路由表表项和其他欧洲C类地址的表项进行匹配。但是由于掩码255.255.240比254.0.0.0更“长”，因此将采用具有更长掩码的路由表表项。

“无类型”的意思是现在的选路决策是基于整个32 bit IP地址的掩码操作，而不管其IP地址是A类、B类或是C类，都没有什么区别。

**CIDR最初是针对新的C类地址提出的。这种变化将使Internet路由表增长的速度缓慢下来，但对于现存的选路则没有任何帮助。这是一个短期解决方案**。作为一个长期解决方案，如果将CIDR应用于所有IP地址，并根据各洲边界和服务提供商对已经存在的IP地址进行重新分配（且所有现有主机重新进行编址！），那么[Ford, Rekhter, and Braun 1993]宣称，目前包含10 000网络表项的路由表将会减少成只有200个表项。

### 11. UDP：用户数据报协议

### 11.1 引言
UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。**这与面向流字符的协议不同，如TCP**，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。

UDP数据报封装成一份IP数据报的格式。RFC 768[Postel 1980]是UDP的正式规范。

UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，我们似乎觉得要避免使用UDP而使用一种可靠协议如TCP。我们在第17章讨论完TCP后将再回到这个话题，看看什么样的应用程序可以使用UDP。

应用程序必须关心IP数据报的长度。如果它超过网络的MTU（2.8节），那么就要对IP数据报进行分片。如果需要，源端到目的端之间的每个网络都要进行分片，并不只是发送端主机连接第一个网络才这样做。在11.5节中，我们将讨论IP分片机制。

### 11.2 UDP首部

![image](https://user-images.githubusercontent.com/34849140/145703793-465e534d-251f-48e4-999a-899ef8914788.png)

端口号表示发送进程和接收进程。在图1-8中，我们画出了TCP和UDP用目的端口号来分用来自IP层的数据的过程。由于IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值），因此TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的。尽管相互独立，如果TCP和UDP同时提供某种知名服务，两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本身的要求。

### 11.3 UDP检验和
UDP检验和覆盖UDP首部和UDP数据。回想**IP首部的检验和，它只覆盖IP的首部—并不覆盖IP数据报中的任何数据**。UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的。

尽管UDP检验和的基本计算方法与我们在3.2节中描述的IP首部检验和计算方法相类似（16 bit字的二进制反码和），但是它们之间存在不同的地方。**首先，UDP数据报的长度可以为奇数字节**，如下图的例子，但是检验和算法是把若干个16 bit字相加。解决方法是必要时在最后增加填充字节0，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）。

其次，UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。**伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地**（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）。UDP数据报中的伪首部格式如图11-3所示。

![image](https://user-images.githubusercontent.com/34849140/145715896-44f5d71d-f201-4f92-a5aa-2db3ecfd6a89.png)

如果检验和的计算结果为0，则存入的值为全1（65535），这在二进制反码计算中是等效的。如果传送的检验和为0，说明发送端没有计算检验和。如果发送端没有计算检验和接收端检测到检验和有差错，那么UDP数据报就要被悄悄地丢弃。不产生任何差错报文（当IP层检测到IP首部检验和有差错时也这样做）。

UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。

### 11.4 IP分片
物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。

把一份IP数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。**重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的**，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。IP首部中包含的数据为分片和重新组装提供了足够的信息。

回忆IP首部（图3-1），下面这些字段用于分片过程。对于发送端发送的每份IP数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中（我们现在已经看到这个字段的用途）。标志字段用其中一个比特来表示“更多的片”。**除了最后一片外，其他每个组成数据报的片都要把该比特置1。片偏移字段指的是该片偏移原始数据报开始处的位置**。另外，当数据报被分片后，每个片的总长度值要改为该片的长度值。

最后，标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。相反把数据报丢弃并发送一个ICMP差错报文（**“需要进行分片但设置了不分片比特”，见图6-3）给起始端。在下一节我们将看到出现这个差错的例子。**

当IP数据报被分片后，每一片都成为一个分组，具有自己的IP首部，并在选择路由时与其他分组独立。这样，当数据报的这些片到达目的端时有可能会失序，但是在IP首部中有足够的信息让接收端能正确组装这些数据报片。

尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报。为什么会发生这种情况呢？因为IP层本身没有超时重传的机制——由更高层来负责超时和重传（TCP有超时和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。当来自TCP报文段的某一片丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报。没有办法只重传数据报中的一个数据报片。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。文献[Kent and Mogul 1987]对避免分片进行了论述。

**使用UDP很容易导致IP分片（在后面我们将看到，TCP试图避免分片**，但对于应用程序来说几乎不可能强迫TCP发送一个需要进行分片的长报文段）。我们可以用sock程序来增加数据报的长度，直到分片发生。在一个以太网上，数据帧的最大长度是1500字节（见图2-1），其中1472字节留给数据，假定IP首部为20字节，UDP首部为8字节。我们分别以数据长度为1471, 1472, 1473和1474字节运行sock程序。最后两次应该发生分片：

![image](https://user-images.githubusercontent.com/34849140/145718438-efe42449-c3d2-4b55-9861-82ac5454e3f4.png)

相应的tcpdump输出如下图所示：

![image](https://user-images.githubusercontent.com/34849140/145718488-52030b97-037f-41e0-b038-524a0b009b84.png)

前两份UDP数据报（第1行和第2行）能装入以太网数据帧，没有被分片。但是对应于写1473字节的IP数据报长度为1501，就必须进行分片（第3行和第4行）。同理，写1474字节产生的数据报长度为1502，它也需要进行分片（第5行和第6行）。当IP数据报被分片后，tcpdump打印出其他的信息。首先，frag 26304（第3行和第4行）和frag 26313（第5行和第6行）指的是**IP首部中标识字段的值**。

分片信息中的下一个数字，即第3行中位于冒号和@号之间的1480，是除IP首部外的片长。两份数据报第一片的长度均为1480：UDP首部占8字节，用户数据占1472字节（加上IP首部的20字节分组长度正好为1500字节）。第1份数据报的第2片（第4行）只包含1字节数据—剩下的用户数据。第2份数据报的第2片（第6行）包含剩下的2字节用户数据。

在分片时，除最后一片外，其他每一片中的数据部分（除IP首部外的其余部分）必须是8字节的整数倍。在本例中，1480是8的整数倍。位于@符号后的数字是从数据报开始处计算的片偏移值。两份数据报第1片的偏移值均为0(第3行和第5行)，第2片的偏移值为1480（第4行和第6行）。跟在偏移值后面的加号对应于IP首部中3 bit标志字段中的“更多片”比特。**设置这一比特的目的是让接收端知道在什么时候完成所有的分片组装。**

最后，注意第4行和第6行（不是第1片）省略了协议名（UDP）、源端口号和目的端口号。**协议名是可以打印出来的，因为它在IP首部并被复制到各个片中。但是，端口号在UDP首部，只能在第1片中被发现。**

发送的第3份数据报（用户数据为1473字节）分片情况如图11-8所示。需要重申的是，任何运输层首部只出现在第1片数据中。

![image](https://user-images.githubusercontent.com/34849140/145718825-96f4704c-f8d0-4469-8b3d-5ed4e09ef4ac.png)

另外需要解释几个术语：`IP数据报`是指IP层端到端的传输单元（在分片之前和重新组装之后），`分组`是指在`IP层和链路层之间传送的数据单元`。一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。

### 11.5 ICMP不可达差错（需要分片）

发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果某个程序需要判断到达目的端的路途中最小MTU是多少—称作路径MTU发现机制（2.9节），那么这个差错就可以被该程序使用。这种情况下的ICMP不可达差错报文格式如图11-9所示。这里的格式与图6-10不同，因为在第2个32 bit字中，16~31 bit可以提供下一站的MTU，而不再是0。

![image](https://user-images.githubusercontent.com/34849140/145719353-c8f3457b-3acc-4bc2-ac69-5bd23e74a91d.png)

如果路由器没有提供这种新的ICMP差错报文格式，那么下一站的MTU就设为0。新版的路由器需求RFC [Almquist 1993]声明，在发生这种ICMP不可达差错时，路由器必须生成这种新格式的报文。

>EXAMPLE:

关于分片作者曾经遇到过一个问题，ICMP差错试图判断从路由器netb到主机sun之间的拨号SLIP链路的MTU。我们知道从sun到netb的链路的MTU：当SLIP被安装到主机sun时，这是SLIP配置过程中的一部分，加上在3.9节中已经通过netstat命令观察过。现在，我们想从**另一个方向来判断它的MTU（在第25章，将讨论如何用SNMP来判断）**。在点到点的链路中，不要求两个方向的MTU为相同值。

所采用的技术是在主机solaris上运行ping程序到主机bsdi，增加数据分组长度，直到看见进入的分组被分片为止。如图11-10所示。

![image](https://user-images.githubusercontent.com/34849140/145909324-b62a4a56-00e6-46d4-baa6-9ab726ac7e38.png)

在主机sun上运行tcpdump，观察SLIP链路，看什么时候发生分片。开始没有观察到分片，一切都很正常直到ping分组的数据长度从500增加到600字节。可以看到接收到的回显请求（仍然没有分片），但不见回显应答。为了跟踪下去，也在主机bsdi上运行tcpdump，观察它接收和发送的报文。输出如图11-11所示。

![image](https://user-images.githubusercontent.com/34849140/145909467-76400e04-0e00-4c2c-88ee-10f588c0a500.png)

首先，每行中的标记（DF）说明在IP首部中设置了不分片比特。这意味着Solaris 2.2一般把不分片比特置1，作为实现路径MTU发现机制的一部分。第1行显示的是回显请求通过路由器netb到达sun主机，没有进行分片，并设置了DF比特，因此我们知道还没有达到netb的SLIP MTU。

接下来，在第2行注意到DF标志被复制到回显应答报文中。这就带来了问题。回显应答与回显请求报文长度相同（超过600字节），但是sun外出的SLIP接口MTU为552。因此回显应答需要进行分片，但是DF标志比特又被设置了。这样，sun就产生一个ICMP不可达差错报文返回给bsdi（报文在bsdi处被丢弃）。这就是我们在主机solaris上没有看到任何回显应答的原因。这些应答永远不能通过sun。分组的路径如图11-12所示。

![image](https://user-images.githubusercontent.com/34849140/145909616-ccd16d1d-4f8f-42c2-8308-0421de7a1f34.png)

最后，在图11-11中的第3行和第6行中，mtu = 0表示主机sun没有在ICMP不可达报文中返回出口MTU值，如图11-9所示（**在25.9节中，将重新回到这个问题，用SNMP判断netb上的SLIP接口MTU值**为1500）。

### 11.6 用Traceroute确定路径MTU

尽管**大多数的系统不支持路径MTU发现功能，但可以很容易地修改traceroute程序（第8章），用它来确定路径MTU。要做的是发送分组，并设置“不分片”标志比特***。发送的第一个分组的长度正好与出口MTU相等，每次收到ICMP“不能分片”差错时（在上一节讨论的）就减小分组的长度。如果路由器发送的ICMP差错报文是新格式，包含出口的MTU，那么就用该MTU值来发送，否则就用下一个最小的MTU值来发送。正如RFC 1191 [Mogul and Deering 1990]声明的那样，MTU值的个数是有限的，因此在我们的程序中有一些由近似值构成的表，取下一个最小MTU值来发送。

首先，我们尝试判断从主机sun到主机slip的路径MTU，知道SLIP链路的MTU为296。

![image](https://user-images.githubusercontent.com/34849140/146092250-4a27b4f0-1b25-4b96-9043-6c4ec9d361c5.png)

在这个例子中，路由器bsdi没有在ICMP差错报文中返回出口MTU，因此我们选择另一个MTU近似值。TTL为2的第1行输出打印的主机名为bsdi，但这是因为它是返回ICMP差错报文的路由器。TTL为2的最后一行正是我们所要找的。

### 11.7 采用UDP的路径MTU发现

>下面对使用UDP的应用程序与路径MTU发现机制之间的交互作用进行研究。看一看如果应用程序写了一个对于一些中间链路来说太长的数据报时会发生什么情况。例子如下：

由于我们所使用的支持路径MTU发现机制的唯一系统就是Solaris 2.x，因此，将采用它作为源站发送一份650字节数据报经slip。由于slip主机位于MTU为296的SLIP链路后，因此，任何长于268字节（296－20－8）且“不分片”比特置为1的UDP数据都会使bsdi路由器产生ICMP“不能分片”差错报文。图11-13给出了拓扑结构和MTU。

![image](https://user-images.githubusercontent.com/34849140/146093880-9da00ff0-dd81-4c13-8ea7-f4d43d6ed692.png)

可以用下面的命令行来产生650字节UDP数据报，每两个UDP数据报之间的间隔是5秒：
```shell
solaris % sock -u -i -n10 -w650 -p5 slip discard
```
图11-14是tcpdump的输出结果。**在运行这个例子时，将bsdi设置成在ICMP“不能分片”差错中，不返回下一跳MTU信息**。

在发送的第一个数据报中将DF比特置1（第1行），其结果是从bsdi路由器发回我们可以猜测的结果（第2行）。令人不解的是，发送一个DF比特置1的数据报（第3行），其结果是同样的ICMP差错（第4行）。我们预计这个数据报在发送时应该将DF比特置0。

**第5行结果显示，IP已经知道了发往该目的地址的数据报不能将DF比特置1，因此，IP进而将数据报在源站主机上进行分片**。这与前面的例子中，IP发送经过UDP的数据报，允许具有较小MTU的路由器（在本例中是bsdi）对它进行分片的情况不一样。由于ICMP“不能分片”报文并没有指出下一跳的MTU，因此，看来IP猜测MTU为576就行了。第一次分片（第5行）包含544字节的UDP数据、8字节UDP首部以及20字节IP首部，因此，总IP数据报长度是572字节。第2次分片（第6行）包含剩余的106字节UDP数据和20字节IP首部。

不幸的是，第7行的下一个数据报将其DF比特置1，因此bsdi将它丢弃并返回ICMP差错。这时发生了***IP定时器超时***，通知IP查看是不是因为路径MTU增大了而将DF比特再一次置1。我们可以从第19行和20行看出这个结果。将第7行与19行进行比较，可以看出IP每过30秒就将DF比特置1，以查看路径MTU是否增大了。

![image](https://user-images.githubusercontent.com/34849140/146096807-a6d8da4d-8a3b-4c56-88b3-d6efcb95b927.png)

Ps:
Solaris 2.2无法对单个UDP应用或所有UDP应用关闭该路径MTU发现。只能通过修改ip_path_mtu_discovery参数，在系统一级开放或关闭它。正如在这个例子里所能看到的那样，如果允许路径MTU发现，那么当UDP应用程序写入可能被分片数据报时，该数据报将被丢弃。

solaris的IP层所假设的最大数据报长度（576字节）是不正确的。在图11-13中，我们看到，实际的MTU值是296字节。**这意味着经solaris分片的数据报还将被bsdi分片**。图11-15给出了在目的主机（slip）上所收集到的tcpdump对于第一个到达数据报的输出结果（图11-14的第5行和第6行）。

![image](https://user-images.githubusercontent.com/34849140/146097902-d6aee40e-5fff-4700-9e82-51bd67d25c4c.png)

在本例中，solaris不应该对外出数据报分片，它应该将DF比特置0，让具有最小MTU的路由器来完成分片工作。
现在我们运行同一个例子，只是对路由器bsdi进行修改使其在ICMP“不能分片”差错中返回下一跳MTU。图11-16给出了tcpdump输出结果的前6行。与图11-14一样，前两个数据报同样是将DF比特置1后发送出去的。但是在知道了下一跳MTU后，只产生了3个数据报片，而图11-15中的bsdi路由器则产生了4个数据报片。

![image](https://user-images.githubusercontent.com/34849140/146098148-20f505ff-36b6-41a6-8bf7-9a17bade7321.png)

### 11.8 UDP和ARP之间的交互作用

使用UDP，可以看到UDP与ARP典型实现之间的有趣的（而常常未被人提及）交互作用。
我们用**sock程序来产生一个包含8192字节数据的UDP数据报**。预测这将会在以太网上产生6个数据报片（见习题11.3）。同时也确保在运行该程序前，ARP缓存是清空的，这样，在发送第一个数据报片前必须交换ARP请求和应答。

```shell
bsdi % arp -a  验证A R P高速缓存是空的
bsdi % sock -u -i -nl -w8192 svr4 discard
```

预计在发送第一个数据报片前会先发送一个ARP请求。IP还会产生5个数据报片，这样就提出了我们必须用tcpdump来回答的两个问题：在接收到ARP回答前，其余数据报片是否已经做好了发送准备？如果是这样，那么在ARP等待应答时，它会如何处理发往给定目的的多个报文？下图11-17给出了tcpdump的输出结果。

![image](https://user-images.githubusercontent.com/34849140/146201093-d27457d4-af57-4cf8-a024-c84e84ca9377.png)

在这个输出结果中有一些令人吃惊的结果。首先，在第一个ARP应答返回以前，总共产生了6个ARP请求。我们认为其原因是IP很快地产生了6个数据报片，而每个数据报片都引发了一个ARP请求。

第二，在接收到第一个ARP应答时（第7行），只发送最后一个数据报片（第9行）！看来似乎将前5个数据报片全都丢弃了。实际上，这是ARP的正常操作。在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机。

Ps:Host Requirements RFC要求实现中必须防止这种类型的ARP洪泛（ARP flooding，即以高速率重复发送到同一个IP地址的ARP请求）。建议最高速率是每秒一次。而这里却在4.3 ms内发出了6个ARP请求。

另一个无法解释的不正常的现象是，svr4发回7个，而不是6个ARP应答。

最后要指出的是，在最后一个ARP应答返回后，继续运行tcpdump程序5分钟，以看看svr4是否会返回ICMP“组装超时”差错。并没有发送ICMP差错（我们在图8-2中给出了该消息的格式。code字段为1表示在重新组装数据报时发生了超时）。

在第一个数据报片出现时，IP层必须启动一个定时器。这里“第一个”表示给定数据报的第一个到达数据报片，而不是第一个数据报片（数据报片偏移为0）。正常的定时器值为30或60秒。**如果定时器超时而该数据报的所有数据报片未能全部到达，那么将这些数据报片丢弃。如果不这么做，那些永远不会到达的数据报片（正如我们在本例中所看到的那样）迟早会引起接收端缓存满。**

这里我们没看到ICMP消息的原因有两个。首先，大多数从Berkeley派生的实现从不产生该差错！这些实现会设置定时器，也会在定时器溢出时将数据报片丢弃，但是不生成ICMP差错。第二，并未接收到包含UDP首部的偏移量为0的第一个数据报片（这是被ARP所丢弃的5个报文的第1个）。**除非接收到第一个数据报片，否则并不要求任何实现产生ICMP差错。其原因是因为没有运输层首部，ICMP差错的接收者无法区分出是哪个进程所发送的数据报被丢弃。这里假设上层（TCP或使用UDP的应用程序）最终会超时并重传。**

### 11.9 最大UDP数据报长度

理论上，IP数据报的最大长度是65535字节，这是由IP首部（图3-1）16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。

我们将遇到两个限制因素。
第一，应用程序可能会受到其程序接口的限制。socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于UDP socket，**这个长度与应用程序可以读写的最大UDP数据报的长度直接相关**。现在的大部分系统都默认提供了可读写大于8192字节的UDP数据报（使用这个默认值是因为8192是NFS读写用户数据数的默认值）。
第二个限制来自于TCP/IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。

>EXANPLE:

作者使用sock程序对不同UDP数据报长度进行了试验。在SunOS 4.1.3下使用环回接口的最大IP数据报长度是32767字节。比它大的值都会发生差错。但是从BSD/386到SunOS 4.1.3的情况下，Sun所能接收到最大IP数据报长度为32786字节（即32758字节用户数据）。在Solaris 2.2下使用环回接口，最大可收发IP数据报长度为65535字节。从Solaris 2.2到AIX 3.2.2，发送的最大IP数据报长度可以是65535字节。很显然，这个限制与源端和目的端的实现有关。

我们在3.2节中提过，**要求主机必须能够接收最短为576字节的IP数据报。在许多UDP应用程序的设计中，其应用程序数据被限制成512字节或更小，因此比这个限制值小**。例如，我们在10.4节中看到，路径信息协议总是发送每份数据报小于512字节的数据。我们还会在其他UDP应用程序如DNS（第14章）、TFTP（第15章）、BOOTP（第16章）以及SNMP（第25章）中遇到这个限制。

**数据报截断**

由于IP能够发送或接收特定长度的数据报并不意味着接收应用程序可以读取该长度的数据。因此，UDP编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？不幸的是，该问题的答案取决于编程接口和实现：

典型的Berkeley版socket API对数据报进行截断，并丢弃任何多余的数据。应用程序何时能够知道，则与版本有关（4.3BSD Reno及其后的版本可以通知应用程序数据报被截断）。SVR4下的socket API(包括Solaris 2.x) 并不截断数据报。超出部分数据在后面的读取中返回。它也不通知应用程序从单个UDP数据报中多次进行读取操作。

**在讨论TCP时，我们发现它为应用程序提供连续的字节流，而没有任何信息边界。TCP以应用程序读操作时所要求的长度来传送数据，因此，在这个接口下，不会发生数据丢失。**

### 11.10 ICMP源站抑制差错

我们同样也可以使用UDP产生ICMP“源站抑制(source quench)”差错。当**一个系统（路由器或主机）接收数据报的速度比其处理速度快时，可能产生这个差错**。注意限定词“可能”。即使一个系统已经没有缓存并丢弃数据报，也不要求它一定要发送源站抑制报文。

图11-18给出了ICMP源站抑制差错报文的格式。有一个很好的方案可以在我们的测试网络里产生该差错报文。可以从bsdi通过必须经过拨号SLIP链路的以太网，将数据报发送给路由器sun。由于SLIP链路的速度大约只有以太网的千分之一，因此，我们很容易就可以使其缓存用完。下面的命令行从主机bsdi通过路由器sun发送100个1024字节长数据报给solaris。

我们将数据报发送给标准的丢弃服务，这样，这些数据报将被忽略(这里说的discard之前也没留意过具体意思，不过不影响理解这里的知识点)：
```shell
bsdi % sock -u -i -w1024 -n100 solaris discard
```

图11-19给出了与此命令行相对应的tcpdump输出结果在这个输出结果中，删除了很多行，这只是一个模型。接收前26个数据报时未发生差错；我们只给出了第一个数据报的结果。然而，从第27个数据报开始，每发送一份数据报，就会接收到一份源站抑制差错报文。总共有26 +（74×2）= 174行输出结果。

![image](https://user-images.githubusercontent.com/34849140/146207043-415b917c-f19f-49f6-9e20-aae0b09ff1fa.png)

在本例中，还需要指出的是，sock程序要么没有接收到源站抑制差错报文，要么接收到却将它们忽略了。结果是如果采用UDP协议，那么BSD实现通常忽略其接收到的源站抑制报文（正如我们在21.10节所讨论的那样，TCP接受源站抑制差错报文，并将放慢在该连接上的数据传输速度）。其部分原因在于，在接收到源站抑制差错报文时，导致源站抑制的进程可能已经中止了。

**这个例子重申了UDP是一个非可靠的协议**，它说明了端到端的流量控制。尽管sock程序成功地将100个数据报写入其网络，但只有26个数据报真正发送到了目的端。其他74个数据报可能被中间路由器丢弃。**除非在应用程序中建立一些应答机制，否则发送端并不知道接收端是否收到了这些数据。**

### 11.11 UDP服务器的设计

通常一个客户启动后直接与单个服务器通信，然后就结束了。而对于服务器来说，它启动后处于休眠状态，等待客户请求的到来。对于UDP来说，当客户数据报到达时，服务器苏醒过来，数据报中可能包含来自客户的某种形式的请求消息。

在这里我们所感兴趣的并不是客户和服务器的编程方面（[Stevens 1990]对这些方面的细节进行了讨论），而是**UDP的那些协议特性，影响使用UDP协议的服务器的设计和实现**（我们在18.11节中对TCP服务器的设计进行了描述）。尽管我们所描述的一些特性取决于所使用UDP的实现，但对于大多数实现来说，这些特性是公共的。

#### 11.11.1 客户IP地址及端口号

来自客户的是UDP数据报。IP首部包含源端和目的端IP地址，UDP首部包含了源端和目的端的UDP端口号。**当一个应用程序接收到UDP数据报时，操作系统必须告诉它是谁发送了这份消息，即源IP地址和端口号**。这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户发回应答。

#### 11.11.2 目的IP地址

一些应用程序需要知道数据报是发送给谁的，即目的IP地址。例如，Host Requirements RFC规定，TFTP服务器必须忽略接收到的发往广播地址的数据报（我们分别在第12章和第15章对广播和TFTP进行描述）。

这要求操作系统从接收到的UDP数据报中将目的IP地址交给应用程序。不幸的是，并非所有的实现都提供这个功能。

#### 11.11.3 UDP输入队列

我们在1.8节中说过，**大多数UDP服务器是交互服务器**。这意味着，单个服务器进程对单个UDP端口上（服务器上的名知端口）的所有客户请求进行处理。

通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。这意味着，来自不同客户的差不多同时到达的请求将由UDP自动排队。接收到的UDP数据报以其接收顺序交给应用程序（在应用程序要求交送下一个数据报时）。

然而，**排队溢出造成内核中的UDP模块丢弃数据报的可能性是存在的**。可以进行以下试验。我们在作为UDP服务器的bsdi主机上运行sock程序：
```shell
bsdi % sock -s -u -v -E -R256 -P30 6666
from 140.252.13.33, to 140.252.13.63: 1111111111 从sun发送到广播地址
from 140.252.13.34, to 140.252.13.35: 4444444444444 从svr4发送到单播地址
```
我们指明以下标志：-s表示作为服务器运行，-u表示UDP，-v表示打印客户的IP地址，-E表示打印目的IP地址（该系统支持这个功能）。另外，我们将这个端口的UDP接收缓存设置为256字节（-R），其每次应用程序读取的大小也是这个数（-r）。标志-P30表示创建UDP端口后，先暂停30秒后再读取第一个数据报。这样，我们就有时间在另两台主机上启动客户程序，发送一些数据报，以查看接收队列是如何工作的。

服务器一开始工作，处于其30秒的暂停时间内，我们就在sun主机上启动一个客户，并发送三个数据报:
```shell
sun %sock -u -v 140.252.13.63 6666到以太网广播地址
connected on 140.252.13.33.1252 to 140.252.13.63.6666
1111111111 11字节的数据（新行）
222222222  10字节的数据（新行）
3333333333 12字节的数据（新行）
```
目的地址是广播地址（140.252.13.63）。

我们同时也在主机svr4上启动第2个客户，并发送另外三个数据报：
```shell
svr4 % sock -u -v bsdi 6666
connected on 0.0.0.0.1042 to 140.252.13.35.6666
44444444444444 14字节的数据（新行）
5555555555555555 16字节的数据（新行）
66666666 9字节的数据（新行）
```

首先，我们早些时候在bsdi上所看到的结果表明，应用程序只接收到2个数据报：来自sun的第一个全1报文，和来自svr4的第一个全4报文。其他4个数据报看来全被丢弃。

图11-20给出的tcpdump输出结果表明，所有6个数据报都发送给了目的主机。两个客户的数据报以交替顺序键入：第一个来自sun，然后是来自svr4的，以此类推。同时也可以看出，全部6个数据报大约在12秒内发送完毕，也就是在服务器休眠的30秒内完成的。

![image](https://user-images.githubusercontent.com/34849140/146217901-399941a6-50e2-4944-8e06-34706a6b0ba9.png)

我们可以从本例中看到以下几个要点。首先，应用程序并不知道其输入队列何时溢出。**只是由UDP对超出数据报进行丢弃处理。同时，从tcpdump输出结果，我们看到，没有发回任何信息告诉客户其数据报被丢弃**。这里不存在像ICMP源站抑制这样发回发送端的消息。最后，看来UDP输出队列是FIFO（先进先出）的，而我们在11.9节中所看到的ARP输入却是LIFO（后进先出）的。

#### 11.11.4 限制本地IP地址
